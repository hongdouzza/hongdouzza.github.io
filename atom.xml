<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>红豆zza</title>
  
  <subtitle>有趣的blog</subtitle>
  <link href="https://hongdouzza.github.io/atom.xml" rel="self"/>
  
  <link href="https://hongdouzza.github.io/"/>
  <updated>2024-04-11T06:06:36.948Z</updated>
  <id>https://hongdouzza.github.io/</id>
  
  <author>
    <name>红豆zza</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>并查集作业和一些想法</title>
    <link href="https://hongdouzza.github.io/posts/31b72f78.html"/>
    <id>https://hongdouzza.github.io/posts/31b72f78.html</id>
    <published>2024-04-09T14:02:57.000Z</published>
    <updated>2024-04-11T06:06:36.948Z</updated>
    
    <content type="html"><![CDATA[<h1 id="三个简述题"><a href="#三个简述题" class="headerlink" title="三个简述题"></a>三个简述题</h1><p>ENGLISH</p><p>Q1:Question 1<br><strong>Social network connectivity</strong>. Given a social network containing n members and a log file containing m timestamps at which times pairs of members formed friendships, design an algorithm to determine the earliest time at which all members are connected (i.e., every member is a friend of a friend of a friend … of a friend). Assume that the log file is sorted by timestamp and that friendship is an equivalence relation. The running time of your algorithm should be logm logn or better and use extra space proportional to n.</p><p>A1:We can solve this problem using the weighted quick union algorithm. When initialized, the n members are each in an independent group, and count=n is recorded as the current remaining continuous flux. The weighted union operation is performed each time a log is read, and the remaining continued flux is reduced by 1. When the remaining flux drops to 1, the earliest connection time is the current log time。</p><p>Q2：<strong>Union-find with specific canonical element</strong>. Add a method find() to the<br>find(i) returns the largest element in the connected component containing i. The operations, union(), connected(), and find() should all take logarithmic time or better.For example, if one of the connected components is {1,2,6,9}{1,2,6,9}, then the find method should return 99 for each of the four elements in the connected components.</p><p>A2：We use the weighted quick-union algorithm to solve this problem. When initialized, each data is independent as a group, we define two arrays: arr records the maximum number of each group, arr[i]=i.; sz[i]=1 is the current size of each set of trees. Update arr[Root node of a larger tree] =max(arr[root(p)],arr[root(q)]) when performing the union operation, that is, when connecting a small tree to a large tree. When performing the find (i) operation, return the value of arr[root(i)]</p><p>Q3：<strong>Successor with delete</strong>.Given a set of n integers ={0,1,…,N-1}.S={0,1,…,n−1} and a sequence of requests of the following form:</p><ul><li>Remove x from S</li><li>Find the successor of x: the smallest y in S such that y≥x.</li></ul><p>design a data type so that all operations (except construction)  take logarithmic time or better in the worst case.</p><p>A3:We use quick-union with compression. Design two arrays: parent[], to record the data set, initialized with each element pointing to itself; next[] Record the next successsor for i. When remove x from s is executed, the collection to which x belongs is first pointed to next[next[i]] by uinon(x, next[i]). We optimize the algorithm with path compression when merging the two collections. When we find the current successor to x, return the value next[root[x]]. So we’re going to have a logarithmic complexity</p><h1 id="通过并查集模拟渗流问题（ddl-4-14）"><a href="#通过并查集模拟渗流问题（ddl-4-14）" class="headerlink" title="通过并查集模拟渗流问题（ddl: 4.14）"></a>通过并查集模拟渗流问题（ddl: 4.14）</h1><p>这是Coursera留下的并查集大作业</p><p>渗流模型简述：在给定的n*n网格中，每一个格点有三个状态（关、开、充满水），当水流自上而下能够流通网格时（水的流通方向为上下左右），该模型处于渗流状态。</p><p>问题简述：数学家发现当每个格点打开的概率为p,存在一个阈值p<em> ，当n最足够大时，所有p&gt;p</em> 的模型几乎都处于渗流，而所有p&lt;p<em> 的模型几乎处于阻塞状态。然而数学家无法运用数理方法准确估计p</em> 的值。现在我们在计算机上设计程序模拟该p*。 <img src="image.png" alt="Alt text"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;三个简述题&quot;&gt;&lt;a href=&quot;#三个简述题&quot; class=&quot;headerlink&quot; title=&quot;三个简述题&quot;&gt;&lt;/a&gt;三个简述题&lt;/h1&gt;&lt;p&gt;ENGLISH&lt;/p&gt;
&lt;p&gt;Q1:Question 1&lt;br&gt;&lt;strong&gt;Social network con</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>algorithms1</title>
    <link href="https://hongdouzza.github.io/posts/b3c0369f.html"/>
    <id>https://hongdouzza.github.io/posts/b3c0369f.html</id>
    <published>2024-04-08T05:52:00.000Z</published>
    <updated>2024-04-10T11:59:04.657Z</updated>
    
    <content type="html"><![CDATA[<h1 id="【学习】并查集"><a href="#【学习】并查集" class="headerlink" title="【学习】并查集"></a>【学习】并查集</h1><p>采用princton的Coursera课程：<a href="https://www.coursera.org/learn/algorithms-part1">algorithms1&amp;2</a></p><p>union-find:</p><ul><li>dynamic connecticity</li><li>quick find</li><li>quck union</li><li>improvemnts</li><li>applications</li></ul><h2 id="动态连通性"><a href="#动态连通性" class="headerlink" title="动态连通性"></a>动态连通性</h2><p>union commamd指令: 连接两个对象<br>find/connected query指令： 检查是否有两个对象连通的路径</p><p>应用场景：在编程时，将整数作为数组的索引时<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//以下使用algs4。jar包</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> StdIn.readInt();</span><br><span class="line"> <span class="type">UF</span> <span class="variable">uf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UF</span>(N);</span><br><span class="line"> <span class="keyword">while</span> (!StdIn.isEmpty())</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> StdIn.readInt();</span><br><span class="line"> <span class="type">int</span> <span class="variable">q</span> <span class="operator">=</span> StdIn.readInt();</span><br><span class="line"> <span class="keyword">if</span> (!uf.connected(p, q))</span><br><span class="line"> &#123;</span><br><span class="line"> uf.union(p, q);</span><br><span class="line"> StdOut.println(p + <span class="string">&quot; &quot;</span> + q);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="快速查找-Quick-find"><a href="#快速查找-Quick-find" class="headerlink" title="快速查找(Quick-find)"></a>快速查找(Quick-find)</h2><h3 id="java实现方式"><a href="#java实现方式" class="headerlink" title="java实现方式"></a>java实现方式</h3><p>数据结构：</p><ul><li>长度为N的整数数组 id[]</li><li>当且仅当p和q的id值相同，表示p和q连通<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuickFind</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] id;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">QuickFind</span><span class="params">(<span class="type">int</span> N)</span>&#123;</span><br><span class="line">        id=<span class="keyword">new</span> <span class="title class_">int</span>[N];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">            id[i]=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">connected</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> q)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id[p]==id[q];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Union</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> q)</span>&#123;</span><br><span class="line">        <span class="type">int</span> pid=id[p];</span><br><span class="line">        <span class="type">int</span> qid=id[q];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;id.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(id[i]==pid)&#123;</span><br><span class="line">                id[i]=qid;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a>算法分析：</h3>快速查找too slow？</li><li>cost model: 初始化、union都需要遍历整个数组，复杂度正比于N；查找很快,复杂度为常数</li><li>union太expensive:N**2的复杂度</li></ul><h2 id="快速并集（Quick-union-lazy-approach-）"><a href="#快速并集（Quick-union-lazy-approach-）" class="headerlink" title="快速并集（Quick-union [lazy approach]）"></a>快速并集（Quick-union [lazy approach]）</h2><p>数据结构：树型</p><ul><li>长度为N的整数数组 id[]</li><li>id[i]时id的父节点</li><li>i的root节点为id[id[id[…id[i]…]]]</li></ul><p>对象连通? 判断p和q的根节点是否相同</p><p>集合：当连接两个对象p,q，设置p的根节点为q根节点的id</p><p>java实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QucikUnion</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] id;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">QucikUnion</span><span class="params">(<span class="type">int</span> N)</span>&#123;</span><br><span class="line">        id=<span class="keyword">new</span> <span class="title class_">int</span>[N];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">            id[i]=i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">root</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(id[i]!=i)&#123;</span><br><span class="line">            i=id[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">connected</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> q)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root(p)==root(q);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> q)</span>&#123;</span><br><span class="line">        id[root(p)]=id[root(q)];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>然而quick-union算法也无法适应大规模数据<br>cost model:</p><div class="table-container"><table><thead><tr><th style="text-align:left">algorithm</th><th style="text-align:left">initialize</th><th style="text-align:left">union</th><th style="text-align:left">find</th></tr></thead><tbody><tr><td style="text-align:left">quick-find</td><td style="text-align:left">N</td><td style="text-align:left">N</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">quick-union</td><td style="text-align:left">N</td><td style="text-align:left">N(包含找根节点)</td><td style="text-align:left">N</td></tr></tbody></table></div><p>我们对比快速查找和快速并集，不难发现各自的缺陷</p><p>快速查找:</p><ul><li>并集费时（N）</li><li>树是平展的，但维持平铺的状态需要费时（怎么理解？）</li></ul><p>快速并集：</p><ul><li>树高</li><li>查找费时（N）</li></ul><p>所以，我们接下来对并查做一些改进。</p><h2 id="加权快速并集（Weighted-quick-union）和压缩路径快速并集-Quick-union-with-path-compression"><a href="#加权快速并集（Weighted-quick-union）和压缩路径快速并集-Quick-union-with-path-compression" class="headerlink" title="加权快速并集（Weighted quick-union）和压缩路径快速并集(Quick union with path compression)"></a>加权快速并集（Weighted quick-union）和压缩路径快速并集(Quick union with path compression)</h2><p>我们跟踪记录生成树的大小（包含对象的个数），将其作为权。并集的时候，权轻的树根节点改为权重的根节点。换句话说，就是小树接到大树下，而非前树接到后树下。这样降低所有节点到根节点的平均距离，并且避免树过深的的算法叫<strong>加权快速并查</strong></p><h2 id="加权快速并查"><a href="#加权快速并查" class="headerlink" title="加权快速并查"></a>加权快速并查</h2><p>数据结构：与快速查找相同，<strong>增加sz[i]存储以i为根节点的树的大小（树下包含对象的数量）</strong></p><p>并集：小树接到大树下，实时更新sz[i]<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QucikUnion</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] id;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">QucikUnion</span><span class="params">(<span class="type">int</span> N)</span>&#123;</span><br><span class="line">        id=<span class="keyword">new</span> <span class="title class_">int</span>[N];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">            id[i]=i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">root</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(id[i]!=i)&#123;</span><br><span class="line">            i=id[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">connected</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> q)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root(p)==root(q);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> q)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sz[p]&gt;sz[q])</span><br><span class="line">          &#123;id[root(q)]=root(p);</span><br><span class="line">          sz[p]+=sz[q];</span><br><span class="line">          &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          &#123;id[root(p)]=root(q);</span><br><span class="line">          sz[q]+=sz[p];</span><br><span class="line">          &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>算法分析：</p><p>1.<strong>运行时间的分析</strong>：</p><ul><li>查找：时间和p、q的深度成正比</li><li>并集：时间为常量</li></ul><p>2.<strong>任意节点X最大为lgN</strong></p><p>以下为简答的数学证明（注意：在计算机领域，lgN底数为2）：</p><ol><li><p><strong>定义</strong>：令(N)表示节点总数，(T_i)表示进行了(i)次并集操作后的某个树的大小（节点数），(h_i)表示这个树的高度（即树中任意节点的最大深度）。</p></li><li><p><strong>观察</strong>：在加权快速并集中，每次并集操作都是将一个较小的树连接到一个较大的树上。因此，每次树的大小至少翻倍（对原先的小树而言）。</p></li><li><p><strong>数学归纳</strong>：</p><ul><li><strong>基础情况</strong>：当树大小(T = 1)时，高度(h = 0)，满足(h \leq \lg T)。</li><li><strong>归纳步骤</strong>：假设对于树的大小为(T<em>k)时，其高度(h_k \leq \lg T_k)成立。当执行一次并集操作，将一个大小至少为(T_k)的树连接到另一个大小至少为(T_k)的树上时，结果树的大小至少为(2T_k)，因此新树的高度(h</em>{k+1} = h_k + 1)（因为最多增加一层）。</li></ul></li><li><p><strong>证明</strong>：根据归纳步骤，新的高度(h<em>{k+1} \leq \lg T_k + 1 = \lg (2T_k)(完全二叉树时) = \lg T</em>{k+1})。这证明了在任意时刻，树的高度（深度）(h)总是小于等于(\lg N)，其中(N)是节点总数。</p></li></ol><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>因此，我们可以得出结论，在加权快速并集算法中，任何节点(x)的深度最大为(\lg N)。这个性质保证了查找操作的高效性，因为查找路径长度的上限是对数级别的。</p><div class="table-container"><table><thead><tr><th style="text-align:left">algorithm</th><th style="text-align:left">initialize</th><th style="text-align:left">union</th><th style="text-align:left">find</th></tr></thead><tbody><tr><td style="text-align:left">quick-find</td><td style="text-align:left">N</td><td style="text-align:left">N</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">quick-union</td><td style="text-align:left">N</td><td style="text-align:left">N(包含找根节点)</td><td style="text-align:left">N</td></tr><tr><td style="text-align:left">weighted</td><td style="text-align:left">N</td><td style="text-align:left">lgN(包含找根节点)</td><td style="text-align:left">lgN</td></tr></tbody></table></div><p>我们还可以进一步优化</p><h2 id="路径压缩快速并集"><a href="#路径压缩快速并集" class="headerlink" title="路径压缩快速并集"></a>路径压缩快速并集</h2><p>在快速并集时，在找到根节点时，将之前的检查点重新直接指向根节点，这样压缩了之后的检查路径的算法叫<strong>路径压缩快速并集（Quick union with path compression）</strong></p><p>java实现方式<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">root</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(id[i]!=i)&#123;</span><br><span class="line">        id[i]=id[id[i]];</span><br><span class="line">        i=id[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>但还可以进一步优化算法。</p><h2 id="集大成的玩意儿"><a href="#集大成的玩意儿" class="headerlink" title="集大成的玩意儿"></a>集大成的玩意儿</h2><p>怎么优化呢？</p><p>很简单，加权和路径压缩搅一块儿就好啦。所以诞生了这么个玩意儿。<br><strong>Weighted</strong> quick-union <strong>with path compression</strong>!!</p><p>接下来简单介绍对其平摊分析</p><h3 id="平摊分析（Amortized-analysis）"><a href="#平摊分析（Amortized-analysis）" class="headerlink" title="平摊分析（Amortized analysis）"></a><strong>平摊分析（Amortized analysis）</strong></h3><p>Q:什么是平摊分析？<br>A:是用于算法分析的方法。在使用平摊分析前须知道数据结构<strong>各种操作所可能发生的时间</strong>，并计算出<strong>最坏情况下</strong>的操作情况并加以平均。能够确认<strong>最坏情况性能的每次操作耗费的平均时间</strong>，但不能确认平均情况性能。（from wikipedia）</p><p>1.<strong>Hopcroft-Ulman, Tarjan</strong> 提出：从一个空的数据结构开始，对N个对象执行M次并查集操作（包括查找和合并）最多需要 c<em>(N + M \lg</em> N) 次数组访问。其中，lg<em> N 是迭代对数函数，表示需要多少次迭代对数运算才能使N减少到1以下。这是一个增长非常缓慢的函数，对于所有实际的N值，lg^</em> N 都是一个非常小的常数。如下：</p><ul><li>当 N = 1 时，lg^* N = 0</li><li>当 N = 2 时，lg^* N = 1</li><li>当 N 增加到16时，lg^* N = 3</li><li>直到 N = 65536 时，lg^* N 才变成4</li></ul><p>2.分析可以进一步改进为 N + M \alpha(M, N)，其中 alpha(M, N) 是阿克曼函数的逆函数，也是一个非常慢增长的函数。这表明在实际应用中，加权快速合并算法（Weighted Quick-Union）配合路径压缩（Path Compression，简称WQUPC）的性能非常接近线性时间。</p><p>3.线性时间算法问题：对于M次并查集操作在N个对象上，是否存在线性时间算法？理论上，基于加权快速合并与路径压缩的分析（WQUPC），并不是严格的线性时间。</p><ul><li>然而，实际上，这个算法的性能非常接近线性时间，考虑到数据输入的成本，其代价在常数因子范围内。</li></ul><h3 id="Amazing-Fact"><a href="#Amazing-Fact" class="headerlink" title="Amazing Fact"></a>Amazing Fact</h3><p>！！</p><ul><li><strong>Fredman-Saks</strong> 提出的惊人事实：<strong>不存在严格的线性时间算法</strong>。即便是WQUPC算法，也不能在理论上达到完全的线性时间复杂度。</li></ul><h3 id="WQUPC"><a href="#WQUPC" class="headerlink" title="WQUPC"></a>WQUPC</h3><p>WQUPC通过维护子树大小并在执行查找操作时压缩路径来优化合并操作，使得后续的查找操作更高效。通过这种方式，算法的平均时间复杂度<strong>非常接近线性</strong>，尽管在最坏情况下并非完全线性，但在实际应用中表现出色。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><div class="table-container"><table><thead><tr><th style="text-align:left">algorithm</th><th style="text-align:left">worst-case time</th></tr></thead><tbody><tr><td style="text-align:left">quick-find</td><td style="text-align:left">M N</td></tr><tr><td style="text-align:left">weighted QU</td><td style="text-align:left">M N</td></tr><tr><td style="text-align:left">weighted QU</td><td style="text-align:left">N + M log N</td></tr><tr><td style="text-align:left">QU+compression</td><td style="text-align:left">N + M log N</td></tr><tr><td style="text-align:left">WQUPC</td><td style="text-align:left">N+ M lg*N</td></tr></tbody></table></div><p>事实证明，超级计算机靠暴力无法解决的，超级算法可以</p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>大致应用场景直接抄PPT上的内容了，这块主要讲的是渗流问题</p><ul><li>渗流</li><li>游戏（围棋，Hex）</li><li>动态连通性</li><li>最小公共祖先</li><li>有限状态自动机的等价性</li><li>物理中的Hoshen-Kopelman算法</li><li>Hinley-Milner多态类型推断</li><li>Kruskal’s最小生成树算法</li><li>Fortran中编译等价语句</li><li>形态学属性的开启和关闭</li><li>图像处理中Matlab的bwlabel()函数</li></ul><p>渗流问题Coursera留了一个大作业，下篇具体写</p><h2 id="全篇总结"><a href="#全篇总结" class="headerlink" title="全篇总结"></a>全篇总结</h2><p>并查集主要解决的是动态连通性问题，为了优化算法引入了树模型作为对象连通结构。那么普通的quick-union在面临大规模数据可能遇到两个问题：树过高，路径过长；于是我们分别用加权和路径压缩算法加以解决，最后尝试将加权和路径压缩搅在一起成了本集顶级战力WQUPC。</p><p>接下来要滚去写大作业力</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;【学习】并查集&quot;&gt;&lt;a href=&quot;#【学习】并查集&quot; class=&quot;headerlink&quot; title=&quot;【学习】并查集&quot;&gt;&lt;/a&gt;【学习】并查集&lt;/h1&gt;&lt;p&gt;采用princton的Coursera课程：&lt;a href=&quot;https://www.courser</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>java学习记录2</title>
    <link href="https://hongdouzza.github.io/posts/fd87d377.html"/>
    <id>https://hongdouzza.github.io/posts/fd87d377.html</id>
    <published>2024-04-08T02:45:38.000Z</published>
    <updated>2024-04-09T13:43:13.707Z</updated>
    
    <content type="html"><![CDATA[<h1 id="【JAVA学习笔记2】-数组和java常用类"><a href="#【JAVA学习笔记2】-数组和java常用类" class="headerlink" title="【JAVA学习笔记2】 数组和java常用类"></a>【JAVA学习笔记2】 数组和java常用类</h1><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组的概念：</p><ul><li>一维数组</li><li>二维数组</li><li>Arrays类</li><li>包装类</li><li>字符串类<br>集合类</li></ul><p>数组长度不可变</p><h3 id="对象数组"><a href="#对象数组" class="headerlink" title="对象数组"></a>对象数组</h3><p>数组初始化：int[]x={1,2,3,4};  (静态初始化)<br>声明时不能指定数组长度<br>动态初始化：int []x=new int[12];</p><p>垃圾内存（释放）</p><p>for each语句<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> []a=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i:arr)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>好像没什么好写的，数组这块很简单….</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;【JAVA学习笔记2】-数组和java常用类&quot;&gt;&lt;a href=&quot;#【JAVA学习笔记2】-数组和java常用类&quot; class=&quot;headerlink&quot; title=&quot;【JAVA学习笔记2】 数组和java常用类&quot;&gt;&lt;/a&gt;【JAVA学习笔记2】 数组和java常</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Mysql学习记录1</title>
    <link href="https://hongdouzza.github.io/posts/52057b56.html"/>
    <id>https://hongdouzza.github.io/posts/52057b56.html</id>
    <published>2024-04-01T06:59:12.000Z</published>
    <updated>2024-04-07T15:46:07.902Z</updated>
    
    <content type="html"><![CDATA[<p>这不是mysql学习记录<br>这是mysql<strong>重装记录</strong>。。。。。。<br>半年前装的mysql，密码忘了。开管理员权限怎么也无法跳过密码（纯怨种）。看了日志，说mysql配置出了问题，还可能数据损坏了….这怎么问题越挖越多。咱就是说人越菜，挖的坑越多。</p><p>准备重装了，原来卸载也比较繁琐：删库、删注册表、删软件</p><p>明天重装了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这不是mysql学习记录&lt;br&gt;这是mysql&lt;strong&gt;重装记录&lt;/strong&gt;。。。。。。&lt;br&gt;半年前装的mysql，密码忘了。开管理员权限怎么也无法跳过密码（纯怨种）。看了日志，说mysql配置出了问题，还可能数据损坏了….这怎么问题越挖越多。咱就是说人越菜，</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>阶段随笔</title>
    <link href="https://hongdouzza.github.io/posts/8cc9c8aa.html"/>
    <id>https://hongdouzza.github.io/posts/8cc9c8aa.html</id>
    <published>2024-03-31T10:27:56.000Z</published>
    <updated>2024-04-01T16:11:33.997Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第四周"><a href="#第四周" class="headerlink" title="第四周"></a>第四周</h1><p>之前的事基本告一段落</p><ul><li>藤廊演出还算成功，合奏选曲不合适。每次演出后都很高兴，都有新的朋友</li><li>互联网+成功提桶跑路，不想多说什么，懒得喷（组织架构过于松散）</li><li>养成写博客习惯，挺好</li><li>下个阶段：录制WAGF和吉他中国比赛的视频；把之前写的一些riff、demo发展成完整的曲目</li><li>下周：物理学人类文明PPT、C语言大作业</li><li>幽梦影、词与物读完</li><li>开始学sql数据库知识</li><li>坚持跑步健身！！</li></ul><p>4.2号：<br>我再也不魔改博客了(:cry:),音乐馆给炸了，哈哈哈。算了明天改回aplayer吸底，属于装修走火入魔了。我今天都不敢部署到仓库里（:cold_sweat:）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第四周&quot;&gt;&lt;a href=&quot;#第四周&quot; class=&quot;headerlink&quot; title=&quot;第四周&quot;&gt;&lt;/a&gt;第四周&lt;/h1&gt;&lt;p&gt;之前的事基本告一段落&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;藤廊演出还算成功，合奏选曲不合适。每次演出后都很高兴，都有新的朋友&lt;/li&gt;
&lt;li</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>GO学习记录1</title>
    <link href="https://hongdouzza.github.io/posts/dff1b3b7.html"/>
    <id>https://hongdouzza.github.io/posts/dff1b3b7.html</id>
    <published>2024-03-29T15:43:49.000Z</published>
    <updated>2024-04-01T07:04:30.770Z</updated>
    
    <content type="html"><![CDATA[<h1 id="【Go学习记录】入门"><a href="#【Go学习记录】入门" class="headerlink" title="【Go学习记录】入门"></a>【Go学习记录】入门</h1><p>起步基础先跟着<a href="https://tour.go-zh.org/">Go语言之旅</a><br>基础学习结构：</p><ul><li>包、变量、函数</li><li>流程控制语句</li><li>struct、slice和映射</li><li>方法和接口</li><li>并发</li></ul><h2 id="包、变量、函数"><a href="#包、变量、函数" class="headerlink" title="包、变量、函数"></a>包、变量、函数</h2><ul><li>程序从 main 包开始运行。包名与导入路径的最后一个元素一致。例如，<strong>“math/rand”</strong> 包中的源码均以 <strong>package rand</strong></li><li>尽量分组导入</li><li>一个名字以大写字母开头，那么它就是已导出的。Pizza 就是个已导出名，Pi 也同样，它导出自 math 包。pizza 和 pi 并未以大写字母开头，所以它们是未导出的。在导入一个包时，你只能引用其中已导出的名字。任何 <strong>“未导出”的名字在该包外均无法访问</strong>。</li><li>当连续两个或多个函数的已命名形参类型相同时，除最后一个类型以外，其它都可以省略。如下<code>x int</code>,<code>y int</code>缩写<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li>Go 的返回值可被命名，它们会被视作定义在函数顶部的变量。如下返回了sum<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">split</span><span class="params">(sum <span class="type">int</span>)</span></span> (x, y <span class="type">int</span>) &#123;</span><br><span class="line">x = sum * <span class="number">4</span> / <span class="number">9</span></span><br><span class="line">y = sum - x</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(split(<span class="number">17</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><code>var</code> 语句用于声明一个变量(列表)，跟函数的参数列表一样，类型在最后</li><li><code>:=</code>可在类型明确的地方代替 <code>var</code></li><li><strong>Go 在不同类型的项之间赋值时需要显式转换</strong> </li><li>常量的声明与变量类似，使用 <code>const</code>关键字,不能用 <code>:=</code>语法声明</li></ul><h2 id="流程控制语句"><a href="#流程控制语句" class="headerlink" title="流程控制语句"></a>流程控制语句</h2><ul><li>for循环：Go 的 for 语句后面的三个构成部分外没有小括号<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    sum:=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++&#123;</span><br><span class="line">        sum+=i</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    fmt.Println(sum)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>同样if语句表达式也不需要小括号，同 for 一样， if 语句可以在条件表达式前执行一个简单的语句(<strong>当然作用域只在if大括号内</strong>)。<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pow</span><span class="params">(x, n, lim <span class="type">float64</span>)</span></span> <span class="type">float64</span> &#123;</span><br><span class="line"><span class="keyword">if</span> v := math.Pow(x, n); v &lt; lim &#123;</span><br><span class="line"><span class="keyword">return</span> v</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> lim</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li>defer语句：defer 语句会将函数推迟到<strong>外层函数返回之后执行</strong>（推迟调用的函数<strong>其参数会立即求值</strong>，但直到外层函数返回前该函数都不会被调用），<strong>推迟的函数调用会被压入一个栈（先进后出）中</strong><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;counting&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;done&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>运行结果为<br>counting<br>done<br>9<br>8<br>7<br>6<br>5<br>4<br>3<br>2<br>1<br>0</li></ul><hr><h2 id="struct、slice和映射"><a href="#struct、slice和映射" class="headerlink" title="struct、slice和映射"></a>struct、slice和映射</h2><ul><li>指针：Go的指针保存了值的内存地址。与 C 不同，Go 没有指针运算，其余类似</li><li>结构体指针：有一个指向结构体的指针 <code>p</code>，可通过 <code>(*p).X</code>来访问其字段 <code>X</code>。也可以<strong>隐式间接引用</strong>，直接写 <code>p.X</code></li><li>结构体文法：直接列出字段的值来新分配一个结构体。使用 <code>Name</code>: 语法可以仅列出部分字段。（字段名的顺序无关。）特殊的前缀 &amp; 返回一个指向结构体的指针。<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">X, Y <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">v1 = Vertex&#123;<span class="number">1</span>, <span class="number">2</span>&#125;  <span class="comment">// 创建一个 Vertex 类型的结构体</span></span><br><span class="line">v2 = Vertex&#123;X: <span class="number">1</span>&#125;  <span class="comment">// Y:0 被隐式地赋予</span></span><br><span class="line">v3 = Vertex&#123;&#125;      <span class="comment">// X:0 Y:0</span></span><br><span class="line">p  = &amp;Vertex&#123;<span class="number">1</span>, <span class="number">2</span>&#125; <span class="comment">// 创建一个 *Vertex 类型的结构体（指针）</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(v1, p, v2, v3)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li>数组：<code>var a [10]int</code><h3 id="切片（slice）"><a href="#切片（slice）" class="headerlink" title="切片（slice）"></a>切片（slice）</h3></li><li>切片：GO语言中切片比数组使用更频繁。与Python切片类似，<code>a[low : high]</code>为左闭右开。更改切片的元素会修改其底层数组中对应的元素，与它共享底层数组的切片都会观测到这些修改。</li><li>切片文法：这是一个数组的文法<code>[3]bool&#123;true, true, false&#125;</code><br>现构建一个引用了它的切片：<code>[]bool&#123;true, true, false&#125;</code></li><li>切片长度和容量：切片长度是指自身包含的元素个数，用<code>len()</code>获取;切片容量指的是<strong>切片的第一个元素开始数</strong>，到<strong>其底层数组元素末尾的个数</strong>，用<code>cap()</code>获取</li><li>nil切片：切片的零值是 nil。nil 切片的长度和容量为 0 且没有底层数组。</li><li>用 make 创建切片：切片可以用内建函数 make 来创建，也是创建动态数组的方式。make 函数会分配一个<strong>元素为零值</strong>的数组并返回一个引用了它的切片：<code>a := make([]int, 5)  // len(a)=5</code>要指定它的容量，需向 <code>make</code>传入第三个参数：<code>b := make([]int, 0, 5) /* len(b)=0, cap(b)=5*/    b = b[:cap(b)] /*len(b)=5, cap(b)=5 */  b = b[1:]      /* len(b)=4, cap(b)=4  */</code></li><li>切片可嵌套</li><li><p>append():为切片追加新的元素<code>func append(s []T, vs ...T) []T</code> append的第一个参数 <code>s</code>是一个元素类型为 T 的切片，其余类型为 T 的值将会追加到该切片的末尾。<strong>当 s 的底层数组太小，不足以容纳所有给定的值时，它就会分配一个更大的数组。返回的切片会指向这个新分配的数组。</strong>如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> s []<span class="type">int</span></span><br><span class="line">printSlice(s)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加一个空切片</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">0</span>)</span><br><span class="line">printSlice(s)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个切片会按需增长</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">1</span>)</span><br><span class="line">printSlice(s)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以一次性添加多个元素</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">printSlice(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printSlice</span><span class="params">(s []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;len=%d cap=%d %v\n&quot;</span>, <span class="built_in">len</span>(s), <span class="built_in">cap</span>(s), s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>Range:直接上code(切片这块基本和Python使用相同)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pow = []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">16</span>, <span class="number">32</span>, <span class="number">64</span>, <span class="number">128</span>&#125;</span><br><span class="line"><span class="comment">//第一个值(i)为当前元素的下标，第二个值(v)为该下标所对应元素的一份副本。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> pow &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;2**%d = %d\n&quot;</span>, i, v)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">pow := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">10</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> pow &#123;</span><br><span class="line">pow[i] = <span class="number">1</span> &lt;&lt; <span class="type">uint</span>(i) <span class="comment">// == 2**i</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, value := <span class="keyword">range</span> pow &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%d\n&quot;</span>, value)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h3 id="映射-map"><a href="#映射-map" class="headerlink" title="映射(map)"></a>映射(map)</h3><p>映射将键映射到值。映射的零值为 nil 。<strong>nil 映射既没有键，也不能添加键</strong>。make 函数会返回给定类型的映射，并将其初始化备用。</p><p>映射文法与结构体类似，但要有键名：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">Lat, Long <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> m = <span class="keyword">map</span>[<span class="type">string</span>]Vertex&#123;</span><br><span class="line"><span class="string">&quot;Bell Labs&quot;</span>: Vertex&#123;</span><br><span class="line"><span class="number">40.68433</span>, <span class="number">-74.39967</span>,</span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">&quot;Google&quot;</span>: Vertex&#123;</span><br><span class="line"><span class="number">37.42202</span>, <span class="number">-122.08408</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>修改映射：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line"></span><br><span class="line">m[<span class="string">&quot;Answer&quot;</span>] = <span class="number">42</span></span><br><span class="line">fmt.Println(<span class="string">&quot;The value:&quot;</span>, m[<span class="string">&quot;Answer&quot;</span>])</span><br><span class="line"></span><br><span class="line">m[<span class="string">&quot;Answer&quot;</span>] = <span class="number">48</span></span><br><span class="line">fmt.Println(<span class="string">&quot;The value:&quot;</span>, m[<span class="string">&quot;Answer&quot;</span>])</span><br><span class="line"></span><br><span class="line"><span class="built_in">delete</span>(m, <span class="string">&quot;Answer&quot;</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;The value:&quot;</span>, m[<span class="string">&quot;Answer&quot;</span>])</span><br><span class="line"></span><br><span class="line">v, ok := m[<span class="string">&quot;Answer&quot;</span>]</span><br><span class="line">fmt.Println(<span class="string">&quot;The value:&quot;</span>, v, <span class="string">&quot;Present?&quot;</span>, ok)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>函数的包：Go 函数可以是一个闭包。闭包是一个函数值，它引用了其函数体之外的变量。该函数可以访问并赋予其引用的变量的值，换句话说，该函数被这些变量“绑定”在一起。</p><h2 id="方法和接口"><a href="#方法和接口" class="headerlink" title="方法和接口"></a>方法和接口</h2><p>方法是比较简单的，实际上跟类是一个应用（有方法接受对象的函数）；接口有点难。</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>Go没有类：但可以为结构体类型定义<strong>方法</strong>。方法就是一类带特殊的 <strong>接收者</strong>参数的函数。方法接收者在它自己的参数列表内，位于 func 关键字和方法名之间。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span>&#123;</span><br><span class="line">X, Y <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Vertex)</span></span> Abs() <span class="type">float64</span> &#123;</span><br><span class="line"><span class="keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">v := Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">fmt.Println(v.Abs())</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//也可为非结构体类型声明方法（只能在同一包内定义的类型的接收者声明方法，而不能为其它包内定义的类型（包括 int 之类的内建类型）的接收者声明方法。）</span></span><br><span class="line"><span class="keyword">type</span> MyFloat <span class="type">float64</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f MyFloat)</span></span> Abs() <span class="type">float64</span> &#123;</span><br><span class="line"><span class="keyword">if</span> f &lt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="type">float64</span>(-f)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="type">float64</span>(f)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>为指针接收者声明方法：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">X, Y <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Vertex)</span></span> Abs() <span class="type">float64</span> &#123;</span><br><span class="line"><span class="keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Vertex)</span></span> Scale(f <span class="type">float64</span>) &#123;</span><br><span class="line">v.X = v.X * f</span><br><span class="line">v.Y = v.Y * f</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">v := Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">v.Scale(<span class="number">10</span>)</span><br><span class="line">fmt.Println(v.Abs())</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>由于方法经常需要修改它的接收者，<strong>指针接收者</strong>比<strong>值接收者</strong>更常用。若使用<strong>值接收者</strong>，那么 Scale 方法会对原始 Vertex 值的<strong>副本</strong>进行操作。Scale 方法必须用指针接受者来更改<strong>main 函数中声明的 Vertex 的值</strong>。</p><p>针对指针的函数与方法：</p><ul><li><strong>带指针参数的函数</strong>必须接受一个指针<br><code>var v Vertex  ScaleFunc(v, 5)  // 编译错误！ScaleFunc(&amp;v, 5) // OK</code></li><li>以<strong>指针为接收者的方法</strong>被调用时，接收者<strong>既能为值又能为指针</strong>：<br><code>var v Vertexv.Scale(5)  // OK   p := &amp;v   p.Scale(10) // OK</code><br>所以一般情况下，Go 会将语句 <code>v.Scale(5)</code>解释为 <code>(&amp;v).Scale(5)</code></li></ul><p>所以选择指针为方法接收者的原因有这些：</p><ul><li>方法能够<strong>直接</strong>修改其接收者指向的值</li><li>避免在每次调用方法时<strong>复制</strong>该值。若值的类型为大型结构体时，这样做会更加高效</li></ul><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>接口类型是由<strong>一组方法签名定义的集合</strong>。<br>接口与隐式实现：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">type</span> I <span class="keyword">interface</span> &#123;</span><br><span class="line">M()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">S <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此方法表示类型 T 实现了接口 I，但我们无需显式声明此事。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t T)</span></span> M() &#123;</span><br><span class="line">fmt.Println(t.S)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> i I = T&#123;<span class="string">&quot;hello&quot;</span>&#125;</span><br><span class="line">i.M()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p>接口值：可以像其它值一样传递，可用作函数的参数或返回值。接口值可以看做包含值和具体类型的元组：<code>(value, type)</code><strong>接口值调用方法时会执行其底层类型的同名方法。</strong>(如上例中i调用M()方法执行的是对T的方法)<br>底层为nil接口值：即便接口内的具体值为 nil，方法仍然会被 nil 接收者调用。如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> I <span class="keyword">interface</span> &#123;</span><br><span class="line">M()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">S <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *T)</span></span> M() &#123;</span><br><span class="line"><span class="keyword">if</span> t == <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;&lt;nil&gt;&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(t.S)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> i I</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> t *T</span><br><span class="line">i = t</span><br><span class="line">describe(i)</span><br><span class="line">i.M()</span><br><span class="line"></span><br><span class="line">i = &amp;T&#123;<span class="string">&quot;hello&quot;</span>&#125;</span><br><span class="line">describe(i)</span><br><span class="line">i.M()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>然而nil 接口值既不保存值也不保存具体类型。为 nil 接口调用方法会产生运行时错误。如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> I <span class="keyword">interface</span> &#123;</span><br><span class="line">M()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> i I</span><br><span class="line">describe(i)</span><br><span class="line">i.M()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//i接口的元组内并未包含能够指明该调用哪个 具体 方法的类型</span></span><br></pre></td></tr></table></figure></p><p>空接口：指定了零个方法的接口值<code>interface&#123;&#125;</code>空接口可保存任何类型的值。（因为每个类型都至少实现了零个方法。）空接口被用来处理未知类型的值。常见使用方法：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">describe(i)</span><br><span class="line"></span><br><span class="line">i = <span class="number">42</span></span><br><span class="line">describe(i)</span><br><span class="line"></span><br><span class="line">i = <span class="string">&quot;hello&quot;</span></span><br><span class="line">describe(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">describe</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;(%v, %T)\n&quot;</span>, i, i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>类型断言：提供了访问接口值底层具体值的方式；判断一个接口值是否保存了一个特定的类型，类型断言可返回两个值：其<strong>底层值</strong>以及一个<strong>报告断言是否成功的布尔值</strong>。<code>t, ok := i.(T)</code>(若 i 保存了一个 T，那么 t 将会是其底层值，而 ok 为 true;否则，ok为false而t为T类型的零值)。<strong>类型断言语法和读取一个映射时有相同之处</strong></p><p>类型选择：是一种按顺序从几个类型断言中选择分支的结构。类型选择与一般的 switch 语句相似，不过类型选择中的 case 为类型（而非值）， 它们针对给定接口值所存储的值的类型进行比较。其声明与类型断言 <code>i.(T)</code>的语法相同，<code>T</code>被替换成了关键字 <code>type</code>。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">do</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line"><span class="keyword">switch</span> v := i.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="type">int</span>:</span><br><span class="line">fmt.Printf(<span class="string">&quot;Twice %v is %v\n&quot;</span>, v, v*<span class="number">2</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="type">string</span>:</span><br><span class="line">fmt.Printf(<span class="string">&quot;%q is %v bytes long\n&quot;</span>, v, <span class="built_in">len</span>(v))</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Printf(<span class="string">&quot;I don&#x27;t know about type %T!\n&quot;</span>, v)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">do(<span class="number">21</span>)</span><br><span class="line">do(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">do(<span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>三个常用接口（包）：</p><ul><li>Stringer</li><li>reader</li><li>image</li></ul><p>Stringer：fmt 包中定义的 Stringer 是最普遍的接口之一。它可以用字符串描述自己的类型。fmt 包（还有很多包）都通过此接口来打印值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Stringer <span class="keyword">interface</span> &#123;</span><br><span class="line">    String() <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Reader:<code>io</code>包指定了 <code>io.Reader</code>接口，它表示从数据流的末尾进行读取。<code>io.Reader</code>接口有一个 Read 方法：<code>func (T) Read(b []byte) (n int, err error)</code>;Read 用数据填充给定的字节切片并返回填充的字节数和错误值。在遇到数据流的结尾时，它会返回一个 io.EOF 错误。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;io&quot;</span></span><br><span class="line"><span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">r := strings.NewReader(<span class="string">&quot;Hello, Reader!&quot;</span>)</span><br><span class="line"></span><br><span class="line">b := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">8</span>)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">n, err := r.Read(b)</span><br><span class="line">fmt.Printf(<span class="string">&quot;n = %v err = %v b = %v\n&quot;</span>, n, err, b)</span><br><span class="line">fmt.Printf(<span class="string">&quot;b[:n] = %q\n&quot;</span>, b[:n])</span><br><span class="line"><span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p>图像：image 包定义了 Image 接口：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> image</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Image <span class="keyword">interface</span> &#123;</span><br><span class="line">    ColorModel() color.Model</span><br><span class="line">    Bounds() Rectangle</span><br><span class="line">    At(x, y <span class="type">int</span>) color.Color</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><h3 id="goroutine"><a href="#goroutine" class="headerlink" title="goroutine"></a>goroutine</h3><p>Go程（goroutine）：是由 Go 运行时管理的轻量级线程。<code>go f(x, y, z)</code>会启动一个新的 Go 程并执行。<code>f(x, y, z)f</code>, <code>x</code> , <code>y</code>和 <code>z</code>的求值发生在当前的 Go 程中，而 f 的执行发生在新的 Go 程中。</p><p>Go 程在相同的地址空间中运行，因此在访问共享的内存时必须进行同步,<code>sync</code>包提供了这种能力.</p><h3 id="信道"><a href="#信道" class="headerlink" title="信道"></a>信道</h3><p>信道：带有类型的管道，通过它用信道操作符<code>&lt;-</code> 来发送或者接收值。<br><code>ch &lt;- v    // 将 v 发送至信道 ch v := &lt;-ch  // 从 ch 接收值并赋予 v</code>(“箭头”就是数据流的方向)</p><p>信道在使用前必须创建：<code>ch := make(chan int)</code>默认情况下，发送和接收操作在另一端准备好之前都会阻塞。这使得 Go 程可以在没有<strong>显式的锁或竞态变量的情况下进行同步</strong>。没懂…..以下为<strong>gpt的形象解释</strong></p><blockquote><p>想象一下你正在组织一场接力赛。在这个接力赛中，每个参赛者（代表一个Goroutine）需要等待前一个队友完成他的部分并传递接力棒（代表信道中的数据）给他，然后他才能开始跑。如果前一个队友还没有跑到（即没有数据发送到信道），下一个队友（接收操作）就必须等待。反之，如果一个队友到达并准备传递接力棒，但下一个队友还没有准备好接手，他也需要等待。这个过程确保了所有的参赛者按照正确的顺序开始和完成他们的部分，没有人会跑得太早或太晚，从而无需额外的指示（即无需显式的锁）就自然而然地实现了同步。</p><p>通过使用信道的这种阻塞机制，Go能够在并发程序中简化数据的同步和通信，避免了直接使用锁或处理竞态变量的复杂性。这使得编写并发程序变得更加直观和安全。</p><p>具体例子：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(s []<span class="type">int</span>, c <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">sum := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">sum += v</span><br><span class="line">&#125;</span><br><span class="line">c &lt;- sum <span class="comment">// 将和送入 c</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := []<span class="type">int</span>&#123;<span class="number">7</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">-9</span>, <span class="number">4</span>, <span class="number">0</span>&#125;</span><br><span class="line"></span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"><span class="keyword">go</span> sum(s[:<span class="built_in">len</span>(s)/<span class="number">2</span>], c)</span><br><span class="line"><span class="keyword">go</span> sum(s[<span class="built_in">len</span>(s)/<span class="number">2</span>:], c)</span><br><span class="line">x, y := &lt;-c, &lt;-c <span class="comment">// 从 c 中接收</span></span><br><span class="line"></span><br><span class="line">fmt.Println(x, y, x+y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>带缓冲的信道：将缓冲长度作为第二个参数提供给 make 来初始化一个带缓冲的信道，<code>ch := make(chan int, 100)</code>;<strong>仅当信道的缓冲区填满后，向其发送数据时才会阻塞。当缓冲区为空时，接受方会阻塞</strong></p></blockquote><h3 id="range和close"><a href="#range和close" class="headerlink" title="range和close"></a>range和close</h3><p>发送者可通过<code>close</code>关闭一个信道来表示没有需要发送的值了。接收者可以通过为接收表达式分配第二个参数来测试信道是否被关闭：若没有值可以接收且信道已被关闭，那么在执行完<code>v, ok := &lt;-ch</code>之后<code>ok</code>会被设置为 false。</p><p>循环<code>for i := range c</code>会不断从信道接收值，直到它被关闭。</p><p><strong>WARNING:</strong> 只有发送者才能关闭信道，而接收者不能。向一个已经关闭的信道发送数据会引发程序恐慌（panic）。</p><p><strong>WARNING:</strong> 信道与文件不同，通常情况下无需关闭它们。只有在必须告诉接收者不再有需要发送的值时才有必要关闭，例如终止一个 range 循环。以下为示例：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibonacci</span><span class="params">(n <span class="type">int</span>, c <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">x, y := <span class="number">0</span>, <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">c &lt;- x</span><br><span class="line">x, y = y, x+y</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">close</span>(c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">10</span>)</span><br><span class="line"><span class="keyword">go</span> fibonacci(<span class="built_in">cap</span>(c), c)</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> c &#123;</span><br><span class="line">fmt.Println(i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h3 id="select语句"><a href="#select语句" class="headerlink" title="select语句"></a>select语句</h3><p><code>select</code>语句使一个 Go 程可以等待多个通信操作。</p><p><code>select</code>会阻塞到某个分支可以继续执行为止，这时就会执行该分支。当多个分支都准备好时会随机选择一个执行。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibonacci</span><span class="params">(c, quit <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">x, y := <span class="number">0</span>, <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> c &lt;- x:</span><br><span class="line">x, y = y, x+y</span><br><span class="line"><span class="keyword">case</span> &lt;-quit:</span><br><span class="line">fmt.Println(<span class="string">&quot;quit&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">quit := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">fmt.Println(&lt;-c)</span><br><span class="line">&#125;</span><br><span class="line">quit &lt;- <span class="number">0</span></span><br><span class="line">&#125;()</span><br><span class="line">fibonacci(c, quit)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>没懂…</p><p>默认选择：当 select 中的其它分支都没有准备好时，default 分支就会执行。为了在尝试发送或者接收时不发生阻塞，可使用 default 分支：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> i := &lt;-c:</span><br><span class="line">    <span class="comment">// 使用 i</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="comment">// 从 c 中接收会阻塞时执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="sync-Mutex"><a href="#sync-Mutex" class="headerlink" title="sync.Mutex"></a>sync.Mutex</h3><p>显而易见信道非常适合在各个 Go 程间进行通信。</p><p>但是如果我们并不需要通信呢？如果只是想保证每次只有一个 Go 程能够访问一个共享的变量，从而避免冲突？</p><p>这里涉及的概念叫做 <strong>互斥（mutual*exclusion）</strong> ，我们通常使用 <strong>互斥锁（Mutex）</strong> 这一数据结构来提供这种机制。</p><p>Go 标准库中提供了 <code>sync.Mutex</code>互斥锁类型及其两个方法：</p><ul><li><code>Lock</code></li><li><code>Unlock</code><br>我们可以通过在代码前调用<code>Lock</code>方法，在代码后调用<code>Unlock</code>方法来保证一段代码的互斥执行。参见 <code>Inc</code>方法。</li></ul><p>我们也可以用 defer 语句来保证互斥锁一定会被解锁。（参考<code>Value</code>方法）<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// SafeCounter 的并发使用是安全的。</span></span><br><span class="line"><span class="keyword">type</span> SafeCounter <span class="keyword">struct</span> &#123;</span><br><span class="line">v   <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span></span><br><span class="line">mux sync.Mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Inc 增加给定 key 的计数器的值。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *SafeCounter)</span></span> Inc(key <span class="type">string</span>) &#123;</span><br><span class="line">c.mux.Lock()</span><br><span class="line"><span class="comment">// Lock 之后同一时刻只有一个 goroutine 能访问 c.v</span></span><br><span class="line">c.v[key]++</span><br><span class="line">c.mux.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Value 返回给定 key 的计数器的当前值。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *SafeCounter)</span></span> Value(key <span class="type">string</span>) <span class="type">int</span> &#123;</span><br><span class="line">c.mux.Lock()</span><br><span class="line"><span class="comment">// Lock 之后同一时刻只有一个 goroutine 能访问 c.v</span></span><br><span class="line"><span class="keyword">defer</span> c.mux.Unlock()</span><br><span class="line"><span class="keyword">return</span> c.v[key]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">c := SafeCounter&#123;v: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> c.Inc(<span class="string">&quot;somekey&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">fmt.Println(c.Value(<span class="string">&quot;somekey&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><hr><p>芜湖…..整理完了，（应该是copy完了）；并发这块还不是很懂,其他还比较简单。<br>主要参考：<br>  <a href="https://tour.go-zh.org/">GO语言之旅</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;【Go学习记录】入门&quot;&gt;&lt;a href=&quot;#【Go学习记录】入门&quot; class=&quot;headerlink&quot; title=&quot;【Go学习记录】入门&quot;&gt;&lt;/a&gt;【Go学习记录】入门&lt;/h1&gt;&lt;p&gt;起步基础先跟着&lt;a href=&quot;https://tour.go-zh.org</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>TEST（博客又被我炸了，哈哈）</title>
    <link href="https://hongdouzza.github.io/posts/cd52ad99.html"/>
    <id>https://hongdouzza.github.io/posts/cd52ad99.html</id>
    <published>2024-03-26T13:39:25.000Z</published>
    <updated>2024-03-26T15:27:18.509Z</updated>
    
    <content type="html"><![CDATA[<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>POST的md文档，没有自动生成html文档？或者说html文档内容为空</p><h2 id="今天豆瓣把数据还没写完"><a href="#今天豆瓣把数据还没写完" class="headerlink" title="//今天豆瓣把数据还没写完"></a>//今天豆瓣把数据还没写完</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;测试&quot;&gt;&lt;a href=&quot;#测试&quot; class=&quot;headerlink&quot; title=&quot;测试&quot;&gt;&lt;/a&gt;测试&lt;/h2&gt;&lt;p&gt;POST的md文档，没有自动生成html文档？或者说html文档内容为空&lt;/p&gt;
&lt;h2 id=&quot;今天豆瓣把数据还没写完&quot;&gt;&lt;a href=</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>学生管理系统（C）</title>
    <link href="https://hongdouzza.github.io/posts/8810ab0d.html"/>
    <id>https://hongdouzza.github.io/posts/8810ab0d.html</id>
    <published>2024-03-26T03:52:28.000Z</published>
    <updated>2024-04-05T06:57:18.123Z</updated>
    
    <content type="html"><![CDATA[<h1 id="【C大作业】学生成绩管理系统（DDL：3-31）"><a href="#【C大作业】学生成绩管理系统（DDL：3-31）" class="headerlink" title="【C大作业】学生成绩管理系统（DDL：3.31）"></a>【C大作业】学生成绩管理系统（DDL：3.31）</h1><p> 背景：坏了，copy的代码还没读完，明天要交了（:cold_sweat:）</p><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>背景设置：</p><ul><li>教学班学生人数和课程门数受限制：<strong>学生人数&lt;=50</strong>，<strong>课程门数&lt;=10</strong></li><li>采用<strong>链表</strong>构成所有学生记录</li><li>使用结构体表示每个学生信息（学号、姓名、考试成绩）</li></ul><p>系统具备的功能：</p><ul><li>增：增加后的记录&lt;=50</li><li>删：删除多条记录</li><li>查：按<strong>学号和姓名</strong>查询</li><li>改</li><li>计算每位学生成绩总分和平均分</li><li>计算每门课总分和平均分</li><li>对学生记录排序：按学号升序、按姓名字典排序、按成绩总分/平均分排序</li><li>对学生记录统计：按成绩总分/平均分统计各个分数段的人数、占比，统计各个分数段人数、占比</li><li>数据存储：记录存盘操作，从磁盘读取已有学生记录</li></ul><h2 id="业务流程分析"><a href="#业务流程分析" class="headerlink" title="业务流程分析"></a>业务流程分析</h2><h2 id="文件结构："><a href="#文件结构：" class="headerlink" title="文件结构："></a>文件结构：</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;【C大作业】学生成绩管理系统（DDL：3-31）&quot;&gt;&lt;a href=&quot;#【C大作业】学生成绩管理系统（DDL：3-31）&quot; class=&quot;headerlink&quot; title=&quot;【C大作业】学生成绩管理系统（DDL：3.31）&quot;&gt;&lt;/a&gt;【C大作业】学生成绩管理系统</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>java_Learning1</title>
    <link href="https://hongdouzza.github.io/posts/dc874005.html"/>
    <id>https://hongdouzza.github.io/posts/dc874005.html</id>
    <published>2024-03-25T02:27:21.000Z</published>
    <updated>2024-03-29T06:01:20.012Z</updated>
    
    <content type="html"><![CDATA[<h1 id="【JAVA学习笔记1】-面向对象基础"><a href="#【JAVA学习笔记1】-面向对象基础" class="headerlink" title="【JAVA学习笔记1】 面向对象基础"></a>【JAVA学习笔记1】 面向对象基础</h1><p>JAVA知识点多，写点笔记，整理3.25 周一上午JAVA课内容，</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="private字段"><a href="#private字段" class="headerlink" title="private字段"></a>private字段</h3><p>当字段被修饰为<code>private</code>时，外部代码无法访问该字段。我们可以用调用类里的方法间接访问该字段，确保了封装性和安全性</p><h3 id="private方法"><a href="#private方法" class="headerlink" title="private方法"></a>private方法</h3><p>和<code>private</code>字段一样，<code>private</code>方法也不允许类外的代码调用。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">ming</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        ming.setBirth(<span class="number">2008</span>);</span><br><span class="line">        System.out.println(ming.getAge());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> birth;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBirth</span><span class="params">(<span class="type">int</span> birth)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.birth = birth;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> calcAge(<span class="number">2019</span>); <span class="comment">// 调用private方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// private方法:</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">calcAge</span><span class="params">(<span class="type">int</span> currentYear)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> currentYear - <span class="built_in">this</span>.birth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><blockquote><p>观察上述代码，<code>calcAge()</code>是一个<code>private</code>方法，外部代码无法调用，但是，内部方法<code>getAge()</code>可以调用它。此外，我们还注意到，这个<code>Person</code>类只定义了<code>birth</code>字段，没有定义<code>age</code>字段，获取<code>age</code>时，通过方法<code>getAge()</code>返回的是一个实时计算的值，并非存储在某个字段的值。这说明方法可以封装一个类的对外接口，调用方不需要知道也不关心<code>Person</code>实例在内部到底有没有<code>age</code>字段。</p></blockquote><h3 id="可变参数（E）"><a href="#可变参数（E）" class="headerlink" title="可变参数（E）"></a>可变参数（E）</h3><p>可变参数用类型…定义，可变参数相当于数组类型：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String[] names;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNames</span><span class="params">(String... names)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.names = names;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>上面的<code>setNames()</code>就定义了一个可变参数。调用时，可以这么写：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Animal</span> <span class="variable">g</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Animal</span>();</span><br><span class="line">g.setNames(<span class="string">&quot;cat&quot;</span>, <span class="string">&quot;dog&quot;</span>, <span class="string">&quot;cow&quot;</span>); <span class="comment">// 传入3个String</span></span><br><span class="line">g.setNames(<span class="string">&quot;cat&quot;</span>, <span class="string">&quot;dog&quot;</span>); <span class="comment">// 传入2个String</span></span><br><span class="line">g.setNames(<span class="string">&quot;cat&quot;</span>); <span class="comment">// 传入1个String</span></span><br><span class="line">g.setNames(); <span class="comment">// 传入0个String</span></span><br></pre></td></tr></table></figure><br>完全可以把可变参数改写为<code>String[]</code>类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String[] names;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNames</span><span class="params">(String[] names)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.names = names;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，调用方需要自己先构造<code>String[]</code>，比较麻烦。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Animal</span> <span class="variable">g</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Animal</span>();</span><br><span class="line">g.setNames(<span class="keyword">new</span> <span class="title class_">String</span>[] &#123;<span class="string">&quot;cat&quot;</span>, <span class="string">&quot;dog&quot;</span>, <span class="string">&quot;cow&quot;</span>&#125;); <span class="comment">// 传入1个String[]</span></span><br></pre></td></tr></table></figure><p>另一个问题是，调用方可以传入<code>null</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Animal</span> <span class="variable">g</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Animal</span>();</span><br><span class="line">g.setNames(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure><br>而可变参数可以保证无法传入null，因为传入0个参数时，接收到的实际值是一个空数组而不是null。</p><p>可变参数感觉跟重载异曲同工嘛，都由参数形式决定方法的结果。</p><h3 id="参数绑定（E）"><a href="#参数绑定（E）" class="headerlink" title="参数绑定（E）"></a>参数绑定（E）</h3><blockquote><p>调用方把参数传递给实例方法时，调用时传递的值会按参数位置一一绑定。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基本类型参数绑定</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">15</span>; <span class="comment">// n的值为15</span></span><br><span class="line">        p.setAge(n); <span class="comment">// 传入n的值</span></span><br><span class="line">        System.out.println(p.getAge()); <span class="comment">// 15</span></span><br><span class="line">        n = <span class="number">20</span>; <span class="comment">// n的值改为20</span></span><br><span class="line">        System.out.println(p.getAge()); <span class="comment">// 15还是20?</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>此时<code>n</code>和<code>p.age</code>两者互不影响，<code>setAge()</code>方法复制了<code>n</code>的值</p></blockquote><p>重点：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//引用类型参数绑定</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        String[] fullname = <span class="keyword">new</span> <span class="title class_">String</span>[] &#123; <span class="string">&quot;Homer&quot;</span>, <span class="string">&quot;Simpson&quot;</span> &#125;;</span><br><span class="line">        p.setName(fullname); <span class="comment">// 传入fullname数组</span></span><br><span class="line">        System.out.println(p.getName()); <span class="comment">// &quot;Homer Simpson&quot;</span></span><br><span class="line">        fullname[<span class="number">0</span>] = <span class="string">&quot;Bart&quot;</span>; <span class="comment">// fullname数组的第一个元素修改为&quot;Bart&quot;</span></span><br><span class="line">        System.out.println(p.getName()); <span class="comment">// &quot;Homer Simpson&quot;还是&quot;Bart Simpson&quot;?</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String[] name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name[<span class="number">0</span>] + <span class="string">&quot; &quot;</span> + <span class="built_in">this</span>.name[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String[] name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><code>fullname</code>和<code>name</code>同步更改，原因是<code>new String[]&#123;&#125;</code><strong>创建了一个对象</strong>，而<code>fullname</code>和<code>p.name</code><strong>指向了同一个对象</strong>。关键是创建了一个对象</p><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p> 构造方法初始化实例，<strong>构造方法名就是类名</strong>，<strong>无返回值</strong>。<br> 调用该方法，必须用<code>new</code>操作符</p><p> 如果既对字段进行初始化，又在构造方法中对字段进行初始化,会发生什么？</p><p> 在Java中，创建对象实例的时候，按照如下顺序进行初始化：</p><ul><li><p>先初始化字段：int age = 10;表示字段初始化为10，double salary;表示字段默认初始化为0，String name;表示引用类型字段默认初始化为null；</p></li><li><p>执行构造方法的代码进行初始化。</p></li></ul><p>因此，构造方法的代码是后运行，将覆盖一开始字段初始化。</p><p>多构造方法，用法类似方法重载。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = <span class="number">12</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h2 id="方法重载-OverLoad-："><a href="#方法重载-OverLoad-：" class="headerlink" title="方法重载(OverLoad)："></a>方法重载(<code>OverLoad</code>)：</h2><p><strong>同一个类</strong>里定义几个<strong>方法名相同</strong>，功能相似但<strong>参数不同</strong>（参数个数、参数类型不同）的<strong>方法</strong></p><p>换而言之，以参数内容决定方法内容，省去多个函数名</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, &quot;</span> + name + <span class="string">&quot;!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (age &lt; <span class="number">18</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Hi, &quot;</span> + name + <span class="string">&quot;!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Hello, &quot;</span> + name + <span class="string">&quot;!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//当前对象是p1；</span></span><br><span class="line">p1.distance(p2);</span><br><span class="line"><span class="comment">//static?</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">double</span> <span class="title function_">distance</span><span class="params">(Point c,Point d)</span>&#123;&#125;<span class="comment">//类是一种数据类型，static静态函数可省略调用对象</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h2 id="其他知识点"><a href="#其他知识点" class="headerlink" title="其他知识点"></a>其他知识点</h2><p><code>this</code>的用法、对象运算符、匿名对象（类）、包和修饰符</p><h3 id="this-用法"><a href="#this-用法" class="headerlink" title="this 用法"></a>this 用法</h3><ul><li>调用类内的成员变量<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> num;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNum</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.num = num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>调用本类中的其他方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> num;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(MyClass mc)</span> &#123;</span><br><span class="line">        System.out.println(mc.num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>调用本类中的其他构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> num;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyClass</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyClass</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.num = num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="对象运算符-instanceof"><a href="#对象运算符-instanceof" class="headerlink" title="对象运算符(instanceof)"></a>对象运算符(instanceof)</h3><p>该运算符用于操作对象实例，检查该对象是否是一个特定类型（类类型或接口类型）。</p><p><code>instanceof</code>运算符使用格式如下：</p><p>( Object reference variable ) instanceof  (class/interface type)<br>如果运算符左侧变量所指的对象，是操作符右侧类或接口(class/interface)的一个对象，那么结果为真。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;James&quot;</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> name <span class="keyword">instanceof</span> String; <span class="comment">// 由于 name 是 String 类型，所以返回真</span></span><br></pre></td></tr></table></figure><p>如果被比较的对象兼容于右侧类型，该运算符仍然返回 true。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vehicle</span> &#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Car</span> <span class="keyword">extends</span> <span class="title class_">Vehicle</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">      <span class="type">Vehicle</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Car</span>();</span><br><span class="line">      <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span>  a <span class="keyword">instanceof</span> Car;</span><br><span class="line">      System.out.println( result);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上实例编译运行结果为：<code>true</code></p><h3 id="匿名对象"><a href="#匿名对象" class="headerlink" title="匿名对象"></a>匿名对象</h3><p>普通的类对象在使用时会<strong>定义一个类类型的变量</strong>，用来保存new出来的类所在的地址。而匿名类取<strong>消掉了这个变量</strong>，这个地址由编译器来处理，并且在new出来之后，它占用的内存会有<strong>JVM自动回收掉</strong>。后续无法再使用了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">classBegin</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;豆zza来喽ヘ(~ω~ヘ)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Student</span>().classBegin();</span><br></pre></td></tr></table></figure><p>匿名对象最常用的方式是<strong>作为函数的参数</strong>，上述的打印语句 “豆zza来喽ヘ(~ω~ヘ)” 是一个匿名对象，由于字符串是以对象的形式存储的，所以这里实际上就是一个<strong>没有使用对象引用的匿名对象</strong>。</p><h3 id="匿名类"><a href="#匿名类" class="headerlink" title="匿名类"></a>匿名类</h3><p>如果一个内部类在整个操作中<strong>只使用一次</strong>，就可以定义为匿名内部类。匿名内部类也就是没有名字的内部类，这是java为了方便我们编写程序而设计的一个机制.<strong>只创建一个它的对象</strong>，以后再不会用到这个类，使用匿名内部类就比较合适。</p><p>匿名内部类伴随着接口一起使用:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">USB</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">USB</span> <span class="variable">usb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">USB</span>()&#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        usb.open();</span><br><span class="line">        usb.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用匿名内部类的匿名对象的方式</span></span><br><span class="line">        <span class="type">USB</span> <span class="variable">usb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">USB</span>()&#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">        &#125;.open();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在Demo这个类的main方法中创建了一个局部的内部类，这个内部类没有名字，也就是创建了一个匿名内部类。</p><p>匿名对象（类）中文本均来自 *<a href="https://cloud.tencent.com/developer/article/1444362">Java 学习笔记(8)——匿名对象与内部类</a></p><h3 id="包-package"><a href="#包-package" class="headerlink" title="包(package)"></a>包(package)</h3><ul><li>将功能相近的类放在同一个包里</li><li>某些访问是以包为单位</li><li>由于不同包里可能有相同的类名，一定程度上可以避免命名冲突</li><li>package语句必须是文件中第一条语句</li><li><strong>WARNING</strong> :包没有父子关系。java.util和java.util.zip是不同的包，两者没有任何继承关系。</li></ul><h3 id="private、public、protected、无修饰"><a href="#private、public、protected、无修饰" class="headerlink" title="private、public、protected、无修饰"></a>private、public、protected、无修饰</h3><div class="table-container"><table><thead><tr><th style="text-align:left">访问级别</th><th style="text-align:left">访问控制修饰符</th><th style="text-align:left">同类</th><th style="text-align:left">同包</th><th style="text-align:left">子类</th><th style="text-align:left">不同包</th></tr></thead><tbody><tr><td style="text-align:left">公开</td><td style="text-align:left">public</td><td style="text-align:left">✔</td><td style="text-align:left">✔</td><td style="text-align:left">✔</td><td style="text-align:left">✔</td></tr><tr><td style="text-align:left">受保护</td><td style="text-align:left">protected</td><td style="text-align:left">✔</td><td style="text-align:left">✔</td><td style="text-align:left">✔</td><td style="text-align:left">×</td></tr><tr><td style="text-align:left">默认</td><td style="text-align:left">无修饰符</td><td style="text-align:left">✔</td><td style="text-align:left">✔</td><td style="text-align:left">×</td><td style="text-align:left">×</td></tr><tr><td style="text-align:left">私有</td><td style="text-align:left">private</td><td style="text-align:left">✔</td><td style="text-align:left">×</td><td style="text-align:left">×</td><td style="text-align:left">×</td></tr></tbody></table></div><hr><p>主要参考：</p><ul><li>java上课内容</li><li><a href="https://www.liaoxuefeng.com/wiki/1252599548343744">廖雪峰java课堂</a></li><li><a href="https://cloud.tencent.com/developer/article/1444362">Java 学习笔记(8)——匿名对象与内部类</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;【JAVA学习笔记1】-面向对象基础&quot;&gt;&lt;a href=&quot;#【JAVA学习笔记1】-面向对象基础&quot; class=&quot;headerlink&quot; title=&quot;【JAVA学习笔记1】 面向对象基础&quot;&gt;&lt;/a&gt;【JAVA学习笔记1】 面向对象基础&lt;/h1&gt;&lt;p&gt;JAVA知识</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>下学期任务清单</title>
    <link href="https://hongdouzza.github.io/posts/2cb79163.html"/>
    <id>https://hongdouzza.github.io/posts/2cb79163.html</id>
    <published>2024-03-21T15:30:46.000Z</published>
    <updated>2024-03-26T12:48:32.559Z</updated>
    
    <content type="html"><![CDATA[<h1 id="【随笔】大一下的开学"><a href="#【随笔】大一下的开学" class="headerlink" title="【随笔】大一下的开学"></a>【随笔】大一下的开学</h1><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>3月2号开学，嗯，现在大概三个星期过去了。除了离散、大物、近代史，其他课一概是能翘就翘，不能翘就写作业，属实无聊。无聊嘛，就水水杭助群，翻翻大佬们的博客(<del>虽然越刷越焦虑</del>:joy:)。但刷着刷着，想起这样一句话</p><blockquote><p>人无癖，不可交   ——《幽梦影》  </p><p>人无癖，不可交。所谓“癖”，是内心充满热情的源头。而我身上热情和勇气几乎已经被迷茫和焦虑压垮了。</p></blockquote><h3 id="迷茫与焦虑"><a href="#迷茫与焦虑" class="headerlink" title="迷茫与焦虑"></a>迷茫与焦虑</h3><p>   说实话，java课硬生生上成了语法课，三节课昏昏沉沉过去，结果对自己“要学”的一无所知。高数课也是如此，真不如我自学，半个小时能抵得上她讲三节课。  </p><p>   必修课是这个状态，那么想着给自己补点人文素养，选了几门人文公选课。一个是讲道德经的，打着当代价值的旗号，<strong>实质除了给现有世界政治经济模式背书，就空空如也</strong>，讲课没有批判力，更没有辩证法，漫画化、正面化的成功人士充斥课堂。WTO嘛，蜻蜓点水，简单性介绍知识，没意思。  </p><p>   这些都是热门课，公评所谓“有真才”“给分高”，去年抢到手可是兴奋了好一阵子，可事实证明</p><blockquote><p>人不能总抱有过高的期待</p></blockquote><p>   最近寝室也出现些矛盾，开麦游戏太吵的，说我弹琴太吵，拌了口角，也没有下文；洗衣机也总是洗出纸屑，很烦，结果也没人主动处理干净；今天下文花了半个小时“起草”寝室规定，也不知道能不能开个小会通过规定。<strong>本以为只有五个人的世界是不需要成文规定的</strong></p><p>  最近还有好多事情要做。互联网+的项目感觉<strong>没戏</strong>。看着商业计划书，有虚玄的感觉。我接口一个都没做。(寄:cold_sweat:)下周五，还有个藤廊音乐节，准备带两首ballad过去，合奏还没练好。</p><p>  说起指弹，我的音乐之路。上个月投的<strong>natasha初赛</strong>石沉大海,结果排了一百多名，没进复赛。不过确实，收音没整好，机位又摆的一坨:hankey:，是我的问题，是我的问题…….</p><p>  现在寝室里人越来越少，恋爱的、团建的、开会的，嗯….</p><p><strong>我该何去何从</strong></p><h3 id="何去何从"><a href="#何去何从" class="headerlink" title="何去何从"></a>何去何从</h3><p>我高中时想当物理学家，努力过，算的上中上水平，但属实没有天赋，加上高考失利，读了计算机。身边佬都是打过noip的，上个学期想了一个月的acm，后来还是放弃，恐怕入了队，最后也会被末尾淘汰，实在没有勇气（<del>陪了夫人又折兵</del>）</p><p>读CS，也学大物，没了当初的热情，现在才发觉</p><blockquote><p>物理学不是我的热爱所在</p></blockquote><p>不打acm，不想去学生组织，想着总要有个技术团体吧，在计科协的介绍下认识了杭助。作为小白，啥都不懂，国庆花了一个星期做面试题，最后很幸运过了。现在想想，真的很幸运。在这里，你遇到到一群真心热爱技术的伙伴（<del>尽管我只会复读，插不上话</del>）。</p><p>所以将来，我是找工作呢，还是读研，还是卷GPA保研呢？</p><p>不管那么多，先提升自己再说。</p><h3 id="提升自己"><a href="#提升自己" class="headerlink" title="提升自己"></a>提升自己</h3><p>我大概两条路线：做音乐、做IT技术。列个这学期的清单</p><p> 后端学习清单：</p><ul><li>学完GO</li><li>学习<code>mysql</code>数据库基础</li><li>学<code>Linux</code></li><li>算法学一下（算法竞赛）</li><li><strong>日更博客</strong>（<del>一般是技术博客</del>）</li><li><a href="https://itwanger.gitee.io/tobebetterjavaer/#/docs/xuexiluxian/go">GO进阶之路</a><br><img src="http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/xuexiluxian/go-7.jpg" alt="附上GO学习路线"></li></ul><p>音乐路线任务清单：</p><ul><li>[ ] 学完爵士和声所有内容</li><li>[ ] 在指板上展现理论内容</li><li>[ ] 每周扒带一首</li><li>[ ] 写点曲子</li><li>[ ] 参加WAGF、吉他中国举办的比赛.(今年翻弹组，明年在走原创)</li><li>[ ] 学混音（EQ、压缩、混响、母带）</li></ul><p>就这样吧，现在刚好是22号零点。<strong>搁笔睡觉！</strong></p><span id="more"></span>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;【随笔】大一下的开学&quot;&gt;&lt;a href=&quot;#【随笔】大一下的开学&quot; class=&quot;headerlink&quot; title=&quot;【随笔】大一下的开学&quot;&gt;&lt;/a&gt;【随笔】大一下的开学&lt;/h1&gt;&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;3月2号开学，嗯，现在大概三个星期过去了。除了离散、大物、近代史，其他课一概是能翘就翘，不能翘就写作业，属实无聊。无聊嘛，就水水杭助群，翻翻大佬们的博客(&lt;del&gt;虽然越刷越焦虑&lt;/del&gt;:joy:)。但刷着刷着，想起这样一句话&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;人无癖，不可交   ——《幽梦影》  &lt;/p&gt;
&lt;p&gt;人无癖，不可交。所谓“癖”，是内心充满热情的源头。而我身上热情和勇气几乎已经被迷茫和焦虑压垮了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;迷茫与焦虑&quot;&gt;&lt;a href=&quot;#迷茫与焦虑&quot; class=&quot;headerlink&quot; title=&quot;迷茫与焦虑&quot;&gt;&lt;/a&gt;迷茫与焦虑&lt;/h3&gt;&lt;p&gt;   说实话，java课硬生生上成了语法课，三节课昏昏沉沉过去，结果对自己“要学”的一无所知。高数课也是如此，真不如我自学，半个小时能抵得上她讲三节课。  &lt;/p&gt;
&lt;p&gt;   必修课是这个状态，那么想着给自己补点人文素养，选了几门人文公选课。一个是讲道德经的，打着当代价值的旗号，&lt;strong&gt;实质除了给现有世界政治经济模式背书，就空空如也&lt;/strong&gt;，讲课没有批判力，更没有辩证法，漫画化、正面化的成功人士充斥课堂。WTO嘛，蜻蜓点水，简单性介绍知识，没意思。  &lt;/p&gt;
&lt;p&gt;   这些都是热门课，公评所谓“有真才”“给分高”，去年抢到手可是兴奋了好一阵子，可事实证明&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;人不能总抱有过高的期待&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;   最近寝室也出现些矛盾，开麦游戏太吵的，说我弹琴太吵，拌了口角，也没有下文；洗衣机也总是洗出纸屑，很烦，结果也没人主动处理干净；今天下文花了半个小时“起草”寝室规定，也不知道能不能开个小会通过规定。&lt;strong&gt;本以为只有五个人的世界是不需要成文规定的&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;  最近还有好多事情要做。互联网+的项目感觉&lt;strong&gt;没戏&lt;/strong&gt;。看着商业计划书，有虚玄的感觉。我接口一个都没做。(寄:cold_sweat:)下周五，还有个藤廊音乐节，准备带两首ballad过去，合奏还没练好。&lt;/p&gt;
&lt;p&gt;  说起指弹，我的音乐之路。上个月投的&lt;strong&gt;natasha初赛&lt;/strong&gt;石沉大海,结果排了一百多名，没进复赛。不过确实，收音没整好，机位又摆的一坨:hankey:，是我的问题，是我的问题…….&lt;/p&gt;
&lt;p&gt;  现在寝室里人越来越少，恋爱的、团建的、开会的，嗯….&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我该何去何从&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;何去何从&quot;&gt;&lt;a href=&quot;#何去何从&quot; class=&quot;headerlink&quot; title=&quot;何去何从&quot;&gt;&lt;/a&gt;何去何从&lt;/h3&gt;&lt;p&gt;我高中时想当物理学家，努力过，算的上中上水平，但属实没有天赋，加上高考失利，读了计算机。身边佬都是打过noip的，上个学期想了一个月的acm，后来还是放弃，恐怕入了队，最后也会被末尾淘汰，实在没有勇气（&lt;del&gt;陪了夫人又折兵&lt;/del&gt;）&lt;/p&gt;
&lt;p&gt;读CS，也学大物，没了当初的热情，现在才发觉&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;物理学不是我的热爱所在&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;不打acm，不想去学生组织，想着总要有个技术团体吧，在计科协的介绍下认识了杭助。作为小白，啥都不懂，国庆花了一个星期做面试题，最后很幸运过了。现在想想，真的很幸运。在这里，你遇到到一群真心热爱技术的伙伴（&lt;del&gt;尽管我只会复读，插不上话&lt;/del&gt;）。&lt;/p&gt;
&lt;p&gt;所以将来，我是找工作呢，还是读研，还是卷GPA保研呢？&lt;/p&gt;
&lt;p&gt;不管那么多，先提升自己再说。&lt;/p&gt;
&lt;h3 id=&quot;提升自己&quot;&gt;&lt;a href=&quot;#提升自己&quot; class=&quot;headerlink&quot; title=&quot;提升自己&quot;&gt;&lt;/a&gt;提升自己&lt;/h3&gt;&lt;p&gt;我大概两条路线：做音乐、做IT技术。列个这学期的清单&lt;/p&gt;
&lt;p&gt; 后端学习清单：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;学完GO&lt;/li&gt;
&lt;li&gt;学习&lt;code&gt;mysql&lt;/code&gt;数据库基础&lt;/li&gt;
&lt;li&gt;学&lt;code&gt;Linux&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;算法学一下（算法竞赛）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;日更博客&lt;/strong&gt;（&lt;del&gt;一般是技术博客&lt;/del&gt;）&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://itwanger.gitee.io/tobebetterjavaer/#/docs/xuexiluxian/go&quot;&gt;GO进阶之路&lt;/a&gt;&lt;br&gt;&lt;img src=&quot;http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/xuexiluxian/go-7.jpg&quot; alt=&quot;附上GO学习路线&quot;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;音乐路线任务清单：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;[ ] 学完爵士和声所有内容&lt;/li&gt;
&lt;li&gt;[ ] 在指板上展现理论内容&lt;/li&gt;
&lt;li&gt;[ ] 每周扒带一首&lt;/li&gt;
&lt;li&gt;[ ] 写点曲子&lt;/li&gt;
&lt;li&gt;[ ] 参加WAGF、吉他中国举办的比赛.(今年翻弹组，明年在走原创)&lt;/li&gt;
&lt;li&gt;[ ] 学混音（EQ、压缩、混响、母带）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;就这样吧，现在刚好是22号零点。&lt;strong&gt;搁笔睡觉！&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://hongdouzza.github.io/posts/4a17b156.html"/>
    <id>https://hongdouzza.github.io/posts/4a17b156.html</id>
    <published>2023-10-22T08:44:24.791Z</published>
    <updated>2023-11-14T10:31:03.263Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
