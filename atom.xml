<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>红豆zza</title>
  
  <subtitle>有趣的blog</subtitle>
  <link href="https://hongdouzza.github.io/atom.xml" rel="self"/>
  
  <link href="https://hongdouzza.github.io/"/>
  <updated>2024-12-16T13:12:30.701Z</updated>
  <id>https://hongdouzza.github.io/</id>
  
  <author>
    <name>红豆zza</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hello World</title>
    <link href="https://hongdouzza.github.io/posts/4a17b156.html"/>
    <id>https://hongdouzza.github.io/posts/4a17b156.html</id>
    <published>2024-12-16T13:12:30.701Z</published>
    <updated>2024-12-16T13:12:30.701Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>os 2</title>
    <link href="https://hongdouzza.github.io/posts/49e59b62.html"/>
    <id>https://hongdouzza.github.io/posts/49e59b62.html</id>
    <published>2024-12-15T00:29:41.000Z</published>
    <updated>2024-12-16T13:12:30.701Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>os 复习</title>
    <link href="https://hongdouzza.github.io/posts/1996e6d0.html"/>
    <id>https://hongdouzza.github.io/posts/1996e6d0.html</id>
    <published>2024-12-13T10:47:24.000Z</published>
    <updated>2024-12-16T13:12:30.701Z</updated>
    
    <content type="html"><![CDATA[<h1 id="OS复习：OS概述"><a href="#OS复习：OS概述" class="headerlink" title="OS复习：OS概述"></a>OS复习：OS概述</h1><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p>虚拟化、并发化、持久化</p><ul><li>OS概述：概念、特征、批处理、分时实时、中断和系统调用</li><li>进程：</li><li>内存管理：</li><li>文件系统：</li><li>IO设备：</li></ul><p>鉴于本人大二上在没有先修计组的前提下，稀里糊涂的选了操作系统，所以基础和考研跨考的同学相当。离期末考还有一个月，选择速通</p><p>若想认真学习OS的同学，建议先修计组，参考jyy老师的课</p><h2 id="第一章：-OS基本概述"><a href="#第一章：-OS基本概述" class="headerlink" title="第一章： OS基本概述"></a>第一章： OS基本概述</h2><h3 id="1-1-基本概念"><a href="#1-1-基本概念" class="headerlink" title="1.1 基本概念"></a>1.1 基本概念</h3><p>OS是控制管理系统软硬件，合理阻止调度计算机的工作与资源分配，为用户和软件提供方便接口与环境的程序几何、</p><p>OS也是状态机</p><h4 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h4><p>并发和共享是操作系统基本特征；</p><p><strong>并发</strong>：同一时间间隔执行多个任务；通过CPU分时实现，多道程序交替运行</p><p><strong>共享</strong>：互斥共享、同时访问（分时共享）</p><p><strong>虚拟</strong>： 将逻辑上的映射到计算机硬件实体，常见有虚拟处理器，虚拟存储器（内存管理），虚拟设备（IO设备）</p><p><strong>异步</strong> ：由于资源有限，进程的执行并不是一贯到底，走走停停，拥有不可预知速度</p><h4 id="目标和功能："><a href="#目标和功能：" class="headerlink" title="目标和功能："></a>目标和功能：</h4><h5 id="作为资源管理者"><a href="#作为资源管理者" class="headerlink" title="作为资源管理者"></a>作为资源管理者</h5><p>我们OS接下来四章学习内容就是围绕以下展开</p><ul><li><p>进程管理：运行多个进程时，进程何时创建？何时撤销？何时管理？如何避免冲突？如何合理共享？所以我们要解决的问题包括：进程控制、同步、通信、死锁的处、处理机的调度</p></li><li><p>存储器管理：为了多道程序提供良好环境，提高内存利用率；我们要考虑：内存分配与回收，地址映射、内存保护与共享和内存扩充</p></li><li>文件管理：计算机信息以文件形式存在，我们需要考虑：文件存储空间怎么管理？目录管理？文件读写的管理和保护</li><li>IO设备管理：设备管理要完成用户IO请求，方便用户使用各种设备，提高设备利用率；主要包括：缓冲管理，设备分配，设备处理和虚拟设备</li></ul><p>以上工作都有OS完成，用户无需关注</p><h5 id="作为用户与计算机硬件系统的接口"><a href="#作为用户与计算机硬件系统的接口" class="headerlink" title="作为用户与计算机硬件系统的接口"></a>作为用户与计算机硬件系统的接口</h5><p>用户想要操纵硬件运行程序，OS也相应提供了接口：命令接口和程序接口</p><h6 id="命令接口"><a href="#命令接口" class="headerlink" title="命令接口"></a>命令接口</h6><p>联机控制和脱机控制方式：联机就是用户和OS强交互，你说一句，计算机反馈一句；脱机又称批处理接口，你列清单，计算机逐条完成并反馈</p><h6 id="程序接口"><a href="#程序接口" class="headerlink" title="程序接口"></a>程序接口</h6><p>GUI最终就是通过调用程序接口实现的</p><h4 id="实现对资源的扩充"><a href="#实现对资源的扩充" class="headerlink" title="实现对资源的扩充"></a>实现对资源的扩充</h4><p>OS将裸机改造成功能更强、使用更方便的机子</p><h3 id="1-2-OS的分类"><a href="#1-2-OS的分类" class="headerlink" title="1.2 OS的分类"></a>1.2 OS的分类</h3><ol><li>手工操作：</li><li>批处理：单道批处理和多道批处理</li></ol><h4 id="单道批处理"><a href="#单道批处理" class="headerlink" title="单道批处理"></a>单道批处理</h4><p>将一批作业以脱机方式输入磁带，并在系统上配上监督程序</p><p>内存始终保持一道作业，是自动的（无需人工干预），有序的，单道性</p><p>但是这样造成高速CPU等待低速IO完成，CPU将会摸鱼很长一段时间。这是我们不允许的，应该狠狠压榨CPU，所以为了让CPU提高利用率和吞吐量，我们走多道程序</p><h4 id="多道批处理"><a href="#多道批处理" class="headerlink" title="多道批处理"></a>多道批处理</h4><p>提交的所有作业放在外存上排成一个队列，我们采用一定算法调度这些作业放入内存。这些作业将穿插得共享CPU和IO设备：比方说A进程请求IO操作暂停运行，我们让CPU跑B进程，通过中断机制实现；</p><p>总而言之，我们要让计算机各部门都忙起来，不能有空闲时间</p><h4 id="分时OS"><a href="#分时OS" class="headerlink" title="分时OS"></a>分时OS</h4><p>将处理器分成很短时间片，按时间片轮流将处理器分配给各联机作业使用。</p><p>A进程我给你了5单位的时间片，没完成？不用做了，下学期再来吧；我们让B进程来</p><p>分时OS可以让多个用户通过终端同时共享一台机子；所以我们要确保独立性，不能A修改了B的内容，不能A发了请求，反馈了B的结果</p><p>分时OS不同多道批处理，这里我们更强调人机交互</p><h4 id="实时OS"><a href="#实时OS" class="headerlink" title="实时OS"></a>实时OS</h4><p>当你要发射导弹了，你不能导弹任务没完成，时间片切到另一个任务。这种情况下，我们需要硬实时系统，这些紧急任务不需要时间片排队，这就是实时操作系统</p><h4 id="网路OS和分布式OS"><a href="#网路OS和分布式OS" class="headerlink" title="网路OS和分布式OS"></a>网路OS和分布式OS</h4><p>网络OS为了让网络中各个计算机结合；、</p><p>分布式OS：分布性和并行性。与网络OS不同的是，分布式OS中若干计算机相互协同完成同一任务</p><h3 id="1-3-OS运行环境"><a href="#1-3-OS运行环境" class="headerlink" title="1.3 OS运行环境"></a>1.3 OS运行环境</h3><h4 id="CPU运行模式"><a href="#CPU运行模式" class="headerlink" title="CPU运行模式"></a>CPU运行模式</h4><p>CPU执行两种程序：内核程序，用户应用程序；那么执行这两种性质程序，需要不同级别的指令</p><p>特权指令：IO、关中断、内存清零，存取用于内存保护的寄存器，送PSW到程序状态字寄存器等的指令</p><p>非特权指令：用户直接使用，不涉及内核</p><p>又把CPU运行分为用户态和核心态（尼玛​的，​为什么翻译不统一，什么目态，管态，内核态都有:sweat_smile:）；注意应用程序向操作系统请求服务时通过访管指令，访管指令是非特权的</p><p>OS最底层是一些和硬件关联特紧密的，时钟管理，中断处理，设备驱动；其次则是进程管理，存储器管理和设备管理</p><h5 id="时钟管理"><a href="#时钟管理" class="headerlink" title="时钟管理"></a>时钟管理</h5><p>时钟第一功能就是计时，向用户提供标准时间</p><p>第二呢，就是通过时钟中断机制，实现进程的切换；比方说，在分时OS中，采用时间片轮转调度，那我们就需要给任务设置DDL；而批处理系统通过时钟管理来衡量一个作业的运行程度</p><h5 id="中断机制"><a href="#中断机制" class="headerlink" title="中断机制"></a>中断机制</h5><p>我们之前提到为了提高CPU利用率，要让CPU在IO操作期间执行其他指令，这就需要中断；但现代OS远不止于此，不做详细介绍</p><p>中断机制有一部分属于内核，负责保护和恢复中断现场信息，转移控制权到相关处理程序。这样可以减少中断处理时间，提高系统并行处理能力</p><h5 id="原语"><a href="#原语" class="headerlink" title="原语"></a>原语</h5><p>没懂为啥这么翻译，经典看不懂中文，来看英格利什，atomic Operation：原子操作？</p><p>就像物质一直分割到最小单位一样，计算机程序也一样分割到最小的程序就是原语。原语是一气呵成的，不能中断</p><p>所以重点在atomic,原子性，不可分的</p><ul><li><p>它是最接近底层，硬件的部分</p></li><li><p>具有原子性，操作只能一气呵成</p></li><li><p>运行时间短暂，调用频繁</p></li></ul><p>如何定义原语？关中断。什是关中断？让某段程序不可分割完成后才能进行中断；（关中断应该是关闭中断的意思，服了）</p><h4 id="中断和异常"><a href="#中断和异常" class="headerlink" title="中断和异常"></a>中断和异常</h4><p>我们想从用户态走向内核态时，只能通过中断或者异常</p><p><strong>中断(Interruption)</strong>: </p><ul><li><p>也称外中断，来自CPU执行指令外部的事件。通常用于信息输入和输出；比如IO结束中断和时钟中断;</p></li><li><p>中断分为可屏蔽的，不可屏蔽；前者通过INTR线发出中断请求，改变屏蔽字可以实现多重中断，使中断更加灵活；后者使通过NMI线发出中断请求，通常是紧急的硬件故障；</p></li></ul><p><strong>异常(Exception)</strong>: </p><ul><li><p>内中断，CPU执行指令内部事件。比如程序非法操作码，地址越界，运算溢出，虚拟系统缺页以及专门的陷入指令；异常自然是不可屏蔽的</p></li><li><p>Exception分为故障（Fault）、自陷（Trap）和终止（Abort）。故障比如非法操作码，缺页故障，除数为0，运算溢出；自陷，用户态调用内核程序；终止，使得CPU无法继续执行硬件故障，控制器出错、存储器校验错；、</p></li></ul><p>中断和异常是怎么处理的？</p><p>用户i条指令-&gt; 检测异常-&gt; 打断执行异常或中断处理-&gt;若解决，回到i+1或i指令；若无法解决，终止程序</p><p>注意中断程序和主程序是独立的，没有从属关系</p><h4 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h4><p>按功能分：</p><ul><li>设备管理</li><li>文件管理</li><li>进程控制</li><li>进程通信</li><li>内存管理</li></ul><p>系统调用处理过程：</p><ol><li>将系统调用号和参数压入堆栈；调用指令，执行陷入指令，从用户态转向内核态，再由系统内核和硬件保护被中断现场，将PC和PSW以及通用寄存器内容压入堆栈</li><li>通过分析系统调用类型，转入相应系统调用子程序，通过系统调用号找到system call 的处理子程序入口</li></ol><p>陷入指令，将CPU使用权主动交给内核程序，内核调用相应处理；</p><p>总而言之，用户不能直接执行对系统影响很大的操作，一定是要请求操作系统代理执行内核操作，这样保证了系统稳定性和安全性</p><h3 id="1-4-操作系统结构"><a href="#1-4-操作系统结构" class="headerlink" title="1.4 操作系统结构"></a>1.4 操作系统结构</h3><p>单内核：系统主要功能模块作为一个整体运行</p><p>微内核：内核最基本功能留在内核，其余就移动到用户态；移出的操作系统代码根据分层划分为若干服务程序，相互独立，交互要走位内核通信。</p><p>它里面有啥？</p><ul><li>与硬件相关的</li><li>基本功能</li><li>客户和服务器间的通信</li></ul><p>原本存放在内核中 的进程管理服务，虚拟存储器管理等待都被放在微内核外的一组服务器中实现。他们在微内核架构里 ，是作为进程的，运行在用户态，客户与服务器通过微内核的消息传递机制实现交互</p><p>这样好处是：可靠，其中在核外的某一操作系统模块崩溃，不会影响另一模块；实现解耦</p><p>特点：</p><ul><li>扩展和灵活</li><li>可靠和安全</li><li>可移植</li><li>分布式计算</li></ul><p>然而微内核需要频繁在用户态和核心态转换，执行开销较大，性能不高。</p><h3 id="1-4-操作系统引导"><a href="#1-4-操作系统引导" class="headerlink" title="1.4 操作系统引导"></a>1.4 操作系统引导</h3><p>笔者在折腾Linux深受bios苦，经常调引导</p><ol><li>激活CPU；CPU读取ROM里Boot程序，将指令寄存器设置为BIOS第一条指令，开始执行BIOS</li><li>硬件自检：BIOS在内存最开始空间构建中断向量表。然后通电自检，硬件是否有故障</li><li>加载带有OS的因公安</li><li>加载主引导记录</li><li>扫描硬盘分区表，加载硬盘活动分区</li><li>加载分区引导记录（PBR）</li><li>加载启动管理器：此时，MBR中的引导程序将控制权交给GRUB（如果使用的是GRUB作为启动管理器）。GRUB将展示一个启动菜单，允许用户选择要启动的操作系统（如Linux、Windows等）。GRUB也可以在启动前修改内核参数等设置。</li><li>加载操作系统</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;OS复习：OS概述&quot;&gt;&lt;a href=&quot;#OS复习：OS概述&quot; class=&quot;headerlink&quot; title=&quot;OS复习：OS概述&quot;&gt;&lt;/a&gt;OS复习：OS概述&lt;/h1&gt;&lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>离散报告</title>
    <link href="https://hongdouzza.github.io/posts/fbe9dd7f.html"/>
    <id>https://hongdouzza.github.io/posts/fbe9dd7f.html</id>
    <published>2024-06-05T22:19:32.000Z</published>
    <updated>2024-12-16T13:12:30.705Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题选：图的最短路径算法，A-算法"><a href="#题选：图的最短路径算法，A-算法" class="headerlink" title="题选：图的最短路径算法，A*算法"></a>题选：图的最短路径算法，A*算法</h2><p>求解最短路径的算法有很多，而A*算法无疑是其中最高效率、适用性更强的算法之一。</p><p>概括来说 A*算法=贪心最优搜索+BFS+优先队列=贪心+Dijkstra+优先队列</p><p>A*算法的核心在于估价函数 f=g+h，其效率取决于H函数的设计</p><h3 id="1-贪心最优搜索"><a href="#1-贪心最优搜索" class="headerlink" title="1.贪心最优搜索"></a>1.贪心最优搜索</h3><p>贪心是启发式算法，在寻找图中最短路径时能高效找到局部最优解，但无法保证全局最优解</p><p>具体的实现思想：从起点s出发，寻找i点（i点是距离终点t最近的邻居节点）</p><p>如何找距离终点最近的邻居节点i？如何估计i到t的距离？</p><p>BFS+优先队列；我们用曼哈顿距离估算最短距离。</p><p>然而，这样的贪心算法无法确保我们假定的最优解存在。我们分情况讨论：</p><ul><li>在无障碍网格中，贪心结果是最优解。因为曼哈顿距离一定存在</li><li>在有障碍网格图中，曼哈顿距离不一定存在，可能i节点在走曼哈顿距离时碰壁，回头绕路。因此，在有障碍网格图中，我们不能确保贪心得到存在的最优解。</li></ul><p>然而，无障碍网格图要求这是个连通图，这样大量图无法适用于贪心法。</p><p>总结来看：贪心最优搜索，<strong>只看终点，不看起点</strong>，错了不能改正，没有回头路，而且曼哈顿距离无法绕过障碍</p><h3 id="2-Dijkstra（BFS）算法"><a href="#2-Dijkstra（BFS）算法" class="headerlink" title="2.Dijkstra（BFS）算法"></a>2.Dijkstra（BFS）算法</h3><p>优先队列的Dijkstra 算法能够高校球的起点s到终点t的距离，但是Dijkstra有bfs通病：没有方向，一股脑一层一层往下。但我们需求只有求一条s到t的最短路径,而不是s到图的任意节点的最短路径，这样会遍历大量的节点空间造成浪费。</p><p>总结来看：Dijkstra,<strong>只看起点，不看终点</strong></p><h3 id="A-算法"><a href="#A-算法" class="headerlink" title="A*算法"></a>A*算法</h3><p>其实很多高效复杂的算法都是针对同一种问题基本的不同算法的杂交。举个例子，在探究图的连通性时，我们会用到加权快速并集和路径压缩快速并集，很自然地，将两者结合，我们就会想到Weighted quick-union with path compression</p><p>同理，A<em>算法也是两种基本解决最短路径算法的结合，贪心和Dijkstra，总结来看，<em>*既看起点，也看终点</em></em>，这恰好互补了两种基本算法的缺陷。</p><p>我们用曼哈顿方法作为计算距离的方法 算法代码实例（c++）<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 10 <span class="comment">// 地图的阶数</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">NODE</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x, y;    <span class="comment">// 节点所在位置</span></span><br><span class="line">    <span class="type">int</span> F, G, H; <span class="comment">// G:从起点开始，沿着产的路径，移动到网格上指定方格的移动耗费。</span></span><br><span class="line">    <span class="comment">// H:从网格上那个方格移动到终点B的预估移动耗费，使用曼哈顿距离。</span></span><br><span class="line">    <span class="comment">// F = G + H</span></span><br><span class="line">    <span class="built_in">NODE</span>(<span class="type">int</span> a, <span class="type">int</span> b) &#123; x = a, y = b; &#125;</span><br><span class="line">    <span class="comment">// 重载操作符，使优先队列以F值大小为标准维持堆</span></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> NODE &amp;a) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> F == a.F ? G &gt; a.G : F &gt; a.F;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义方向</span></span><br><span class="line"><span class="comment">//const int next_position[8][2] = &#123;&#123;-1, -1&#125;, &#123;-1, 0&#125;, &#123;-1, 1&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;, &#123;1, -1&#125;, &#123;1, 0&#125;, &#123;1, 1&#125;&#125;;</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> next_position[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">priority_queue&lt;Node&gt; open; <span class="comment">// 优先队列，就相当于open表</span></span><br><span class="line"><span class="comment">// 棋盘</span></span><br><span class="line"><span class="type">int</span> map[N][N] = &#123;&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">                 &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">                 &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">                 &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">                 &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">                 &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">                 &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">                 &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">                 &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">                 &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line"><span class="type">bool</span> close[N][N]; <span class="comment">// 访问情况记录，close列表</span></span><br><span class="line"><span class="type">int</span> valueF[N][N]; <span class="comment">// 记录每个节点对应的F值</span></span><br><span class="line"><span class="type">int</span> pre[N][N][<span class="number">2</span>]; <span class="comment">// 存储每个节点的父节点</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Manhattan</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> x1, <span class="type">int</span> y1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">abs</span>(x - x1) + <span class="built_in">abs</span>(y - y1)) * <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isValidNode</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> xx, <span class="type">int</span> yy)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt;= N || y &lt; <span class="number">0</span> || y &gt;= N)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 判断边界</span></span><br><span class="line">    <span class="keyword">if</span> (map[x][y] == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 判断障碍物</span></span><br><span class="line">    <span class="comment">// 两节点成对角型且它们的公共相邻节点存在障碍物，在8方向时用</span></span><br><span class="line">    <span class="keyword">if</span> (x != xx &amp;&amp; y != yy &amp;&amp; (map[x][yy] == <span class="number">1</span> || map[xx][y] == <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Astar</span><span class="params">(<span class="type">int</span> x0, <span class="type">int</span> y0, <span class="type">int</span> x1, <span class="type">int</span> y1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 起点加入open列表</span></span><br><span class="line">    <span class="function">Node <span class="title">node</span><span class="params">(x0, y0)</span></span>;</span><br><span class="line">    node.G = <span class="number">0</span>;</span><br><span class="line">    node.H = <span class="built_in">Manhattan</span>(x0, y0, x1, y1);</span><br><span class="line">    node.F = node.G + node.H;</span><br><span class="line">    valueF[x0][y0] = node.F;</span><br><span class="line">    open.<span class="built_in">push</span>(node);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!open.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        Node node_current = open.<span class="built_in">top</span>();                   <span class="comment">//取优先队列头元素，即周围单元格中代价最小的点</span></span><br><span class="line">        open.<span class="built_in">pop</span>();                                       <span class="comment">//从open列表中移除</span></span><br><span class="line">        close[node_current.x][node_current.y] = <span class="literal">true</span>;     <span class="comment">// 访问该点，加入close列表</span></span><br><span class="line">        <span class="keyword">if</span> (node_current.x == x1 &amp;&amp; node_current.y == y1) <span class="comment">// 到达终点</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历node_top周围的4个位置，如果是next_position有8，那么就需要遍历周围8个点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">Node <span class="title">node_next</span><span class="params">(node_current.x + next_position[i][<span class="number">0</span>], node_current.y + next_position[i][<span class="number">1</span>])</span></span>; <span class="comment">// 创建一个node_top周围的点</span></span><br><span class="line">            <span class="comment">// 该节点坐标合法 且没有被访问</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isValidNode</span>(node_next.x, node_next.y, node_current.x, node_current.y) &amp;&amp; !close[node_next.x][node_next.y])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 计算从起点并经过node_top节点到达该节点所花费的代价</span></span><br><span class="line">                node_next.G = node_current.G + <span class="built_in">int</span>(<span class="built_in">sqrt</span>(<span class="built_in">pow</span>(next_position[i][<span class="number">0</span>], <span class="number">2</span>) + <span class="built_in">pow</span>(next_position[i][<span class="number">1</span>], <span class="number">2</span>)) * <span class="number">10</span>);</span><br><span class="line">                <span class="comment">// 计算该节点到终点的曼哈顿距离</span></span><br><span class="line">                node_next.H = <span class="built_in">Manhattan</span>(node_next.x, node_next.y, x1, y1);</span><br><span class="line">                <span class="comment">// 从起点经过node_top和该节点到达终点的估计代价</span></span><br><span class="line">                node_next.F = node_next.G + node_next.H;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// node_next.F &lt; valueF[node_next.x][node_next.y] 说明找到了更优的路径，进行更新</span></span><br><span class="line">                <span class="comment">// valueF[node_next.x][node_next.y] == 0 说明该节点还未加入open表中，则加入</span></span><br><span class="line">                <span class="keyword">if</span> (node_next.F &lt; valueF[node_next.x][node_next.y] || valueF[node_next.x][node_next.y] == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 保存该节点的父节点</span></span><br><span class="line">                    pre[node_next.x][node_next.y][<span class="number">0</span>] = node_current.x;</span><br><span class="line">                    pre[node_next.x][node_next.y][<span class="number">1</span>] = node_current.y;</span><br><span class="line">                    valueF[node_next.x][node_next.y] = node_next.F; <span class="comment">// 修改该节点对应的valueF值</span></span><br><span class="line">                    open.<span class="built_in">push</span>(node_next);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintPath</span><span class="params">(<span class="type">int</span> x1, <span class="type">int</span> y1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pre[x1][y1][<span class="number">0</span>] == <span class="number">-1</span> || pre[x1][y1][<span class="number">1</span>] == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;no path to get&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> x = x1, y = y1;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    <span class="keyword">while</span> (x != <span class="number">-1</span> || y != <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        map[x][y] = <span class="number">2</span>; <span class="comment">// 将可行路径上的节点赋值为2</span></span><br><span class="line">        a = pre[x][y][<span class="number">0</span>];</span><br><span class="line">        b = pre[x][y][<span class="number">1</span>];</span><br><span class="line">        x = a;</span><br><span class="line">        y = b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// &#x27; &#x27;表示未经过的节点， &#x27;#&#x27;表示障碍物， &#x27;@&#x27;表示可行节点</span></span><br><span class="line">    string s[<span class="number">3</span>] = &#123;<span class="string">&quot;  &quot;</span>, <span class="string">&quot; #&quot;</span>, <span class="string">&quot; @&quot;</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; N; j++)</span><br><span class="line">            cout &lt;&lt; s[map[i][j]];</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fill</span>(close[<span class="number">0</span>], close[<span class="number">0</span>] + N * N, <span class="literal">false</span>);    <span class="comment">// 将visit数组赋初值false</span></span><br><span class="line">    <span class="built_in">fill</span>(valueF[<span class="number">0</span>], valueF[<span class="number">0</span>] + N * N, <span class="number">0</span>);      <span class="comment">// 初始化F全为0</span></span><br><span class="line">    <span class="built_in">fill</span>(pre[<span class="number">0</span>][<span class="number">0</span>], pre[<span class="number">0</span>][<span class="number">0</span>] + N * N * <span class="number">2</span>, <span class="number">-1</span>); <span class="comment">// 路径同样赋初值-1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//  // 起点 // 终点</span></span><br><span class="line">    <span class="type">int</span> x0 = <span class="number">2</span>, y0 = <span class="number">4</span>, x1 = <span class="number">8</span>, y1 = <span class="number">6</span>;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;test number: &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;t);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (t--)&#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;input start: &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x0, &amp;y0);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;input destination: &quot;</span>);</span><br><span class="line">     <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x1, &amp;y1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">isValidNode</span>(x0, y0, x0, y0))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Invalid input.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Astar</span>(x0, y0, x1, y1); <span class="comment">// A*算法</span></span><br><span class="line">    <span class="built_in">PrintPath</span>(x1, y1);     <span class="comment">// 打印路径</span></span><br><span class="line"></span><br><span class="line">&#125;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p>那这是如何结合两种算法的？</p><ul><li>对于起点s到i的路径，Dijkstra保证最优性</li><li>对于i到t的路径，采用贪心预测，选择i的下一个节点。</li><li>当i碰壁时，i被丢弃；回退到上一层重新选择节点j，而j任由Dijkstra保证最优性</li></ul><p>对于以上具体实现想法，我们设计一个函数抽象的表示： f(i)=g(i)+h(i)   (g反映Dijkstra,h反映贪心)</p><ul><li>显然，g=0，A<em> 退化成贪心；h=0，A</em>退化成Dijkstra</li></ul><p>详细解释一遍：A*更具最小的f(i)选择下一个节点i，g(i)是走过的路径，已知；h(i)是预测未来走的路径，f(i)取决于h(i)的计算</p><p>A*的结果一定是最优吗？</p><p>当i到t终点时，h(t)=0,此时f(t)=g(t)，而g(t)是由Dijstra保证的最短路径，因此A*能够得出最优解</p><p>总的来说，<strong>A*以Dijkstra获得最优结果，用贪心扩展方向，大大减少搜索的节点</strong></p><h3 id="h函数设计"><a href="#h函数设计" class="headerlink" title="h函数设计"></a>h函数设计</h3><p>对于二维平面图，三种办法近似计算h函数，设i的坐标(x1,x2),t(x2,y2)</p><ul><li>曼哈顿距离。节点只能上下左右移动，h(i)=abs(x1-x2)+abs(y1-y2)</li><li>对角线距离，节点能够8个方向上移动（新增东北，西北，东南，西南方向），h(i)=max{abs(x1-x2),abs(y1-y2)}</li><li>欧式距离，节点可以任意方向移动,h(i)=sqrt((x1-x2)<strong> 2+(y1-y2)</strong> 2)</li></ul><p>注意三条规则</p><ul><li>g和h采用相同距离计算方法</li><li>根据具体图的背景信息，选择相应的距离算法</li><li><strong>h优于实际存在的所有路径</strong>，这一点很关键，接下来我们会对此具体讨论<br>1.h(i)  &gt; i-t中存在的最短路径长度。设实际最短路径为path，由于计算h(i)扩展下一个节点，path被抛弃了（因为找到h(i)）,选择非最短路径</li></ul><ol><li>h(i) &lt; i-t中所有路径。这意味着在i-t中不存在长度为h(i)的路径，在搜寻h(i)的路径时，节点一定会碰壁。但这不要紧，因为Dijkstra算法让这些碰壁的点弹出，回退到合适的点，从而扩展出实际路径。</li></ol><p>参考：<a href="https://blog.csdn.net/denghecsdn/article/details/78778769">https://blog.csdn.net/denghecsdn/article/details/78778769</a></p><h3 id="A-算法例题"><a href="#A-算法例题" class="headerlink" title="A*算法例题"></a>A*算法例题</h3><p>from poj 2249</p><p>题面描述:<br>给定N个点，M条有向边。给出起点s和终点t,求其中第K个最短路径。</p><p>注意：若出发点与结束点为同一点，则一定要从出发点跑出去，再跑回来，才算最短路</p><p>第K短路则运用了A ∗ A<em>A∗的排除多余状态与优先队列B F S BFSBFS,第几次取出e d eded,即求到第几短路的性质来解决问题，A ∗ A</em>A∗主要起优化作用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1010</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> n, m, s, t, k;</span><br><span class="line"><span class="type">bool</span> vis[maxn];</span><br><span class="line"><span class="type">int</span> dist[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> v, c;v是节点编号，c是s到v估计值,c是g[i],dist为h[i]</span><br><span class="line">    <span class="built_in">Node</span> (<span class="type">int</span> _v = <span class="number">0</span>, <span class="type">int</span> _c = <span class="number">0</span>): <span class="built_in">v</span>(_v), <span class="built_in">c</span>(_c) &#123;&#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> Node &amp;rhs) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> c + dist[v] &gt; rhs.c + dist[rhs.v];  估价函数 fx = gx + hx 路径短先出队</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> to, cost;</span><br><span class="line">    <span class="built_in">Edge</span> (<span class="type">int</span> _to = <span class="number">0</span>, <span class="type">int</span> _cost = <span class="number">0</span>): <span class="built_in">to</span>(_to), <span class="built_in">cost</span>(_cost) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vector &lt;Edge&gt; E[maxn], revE[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addedge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    E[v].<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(u, w));  反向加边</span><br><span class="line">    revE[u].<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(v, w));  正向加边</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> n)</span>  最短路径，从终点t遍历所有节点，找出所有节点到t的最短路径,即dist[v]为v到t的最短路径h[i]</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        vis[i] = <span class="literal">false</span>;</span><br><span class="line">        dist[i] = inf;</span><br><span class="line">    &#125;</span><br><span class="line">    dist[s] = <span class="number">0</span>;</span><br><span class="line">    priority_queue &lt;Node&gt; Q;</span><br><span class="line">    Q.<span class="built_in">push</span>(<span class="built_in">Node</span>(s, dist[s]));</span><br><span class="line">    <span class="keyword">while</span> (!Q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        Node tmp = Q.<span class="built_in">top</span>();</span><br><span class="line">        Q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> u = tmp.v;</span><br><span class="line">        <span class="keyword">if</span> (vis[u])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        vis[u] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; E[u].<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> v = E[u][i].to, cost = E[u][i].cost;</span><br><span class="line">            <span class="keyword">if</span> (!vis[v] &amp;&amp; dist[v] &gt; dist[u] + cost)</span><br><span class="line">            &#123;</span><br><span class="line">                dist[v] = dist[u] + cost;</span><br><span class="line">                Q.<span class="built_in">push</span>(<span class="built_in">Node</span>(v, dist[v]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">astar</span><span class="params">(<span class="type">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    这里dist已经计算，优先队列排序会按照f[i]=g[i]+h[i](dist[i])排序,<span class="number">55</span>行</span><br><span class="line">    a*算法从s起点开始，通过反向边同样计算最短路径</span><br><span class="line">    priority_queue &lt;Node&gt; Q;</span><br><span class="line">    Q.<span class="built_in">push</span>(<span class="built_in">Node</span>(s, <span class="number">0</span>));</span><br><span class="line">    k--;</span><br><span class="line">    <span class="keyword">while</span> (!Q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        Node tmp = Q.<span class="built_in">top</span>();</span><br><span class="line">        Q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> u = tmp.v;节点编号</span><br><span class="line">        <span class="keyword">if</span> (u == t) 找到终点</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (k)</span><br><span class="line">                --k;</span><br><span class="line">            <span class="keyword">else</span>   第k次到达目标节点t</span><br><span class="line">                <span class="keyword">return</span> tmp.c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; revE[u].<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> v = revE[u][i].to, cost = revE[u][i].cost;</span><br><span class="line">            Q.<span class="built_in">push</span>(<span class="built_in">Node</span>(v, tmp.c + cost));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> u, v, w;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m) != EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            E[i].<span class="built_in">clear</span>();</span><br><span class="line">            revE[i].<span class="built_in">clear</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line">            <span class="built_in">addedge</span>(u, v, w);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;s, &amp;t, &amp;k);</span><br><span class="line">        <span class="built_in">dijkstra</span>(t, n);  t点到所有点的最短路</span><br><span class="line">        <span class="keyword">if</span> (dist[s] == inf)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (s == t)  起点等于终点特判</span><br><span class="line">                ++k;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">astar</span>(s));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题选：图的最短路径算法，A-算法&quot;&gt;&lt;a href=&quot;#题选：图的最短路径算法，A-算法&quot; class=&quot;headerlink&quot; title=&quot;题选：图的最短路径算法，A*算法&quot;&gt;&lt;/a&gt;题选：图的最短路径算法，A*算法&lt;/h2&gt;&lt;p&gt;求解最短路径的算法有很多，而</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>acm</title>
    <link href="https://hongdouzza.github.io/posts/cb875d84.html"/>
    <id>https://hongdouzza.github.io/posts/cb875d84.html</id>
    <published>2024-05-21T14:12:11.000Z</published>
    <updated>2024-12-16T13:12:30.701Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>期末大作业-连连看</title>
    <link href="https://hongdouzza.github.io/posts/b26e54f8.html"/>
    <id>https://hongdouzza.github.io/posts/b26e54f8.html</id>
    <published>2024-05-11T16:37:51.000Z</published>
    <updated>2024-12-16T13:12:30.701Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>栈和队列</title>
    <link href="https://hongdouzza.github.io/posts/8d66b5f2.html"/>
    <id>https://hongdouzza.github.io/posts/8d66b5f2.html</id>
    <published>2024-04-18T19:50:22.000Z</published>
    <updated>2024-12-16T13:12:30.701Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>算法分析</title>
    <link href="https://hongdouzza.github.io/posts/d68e5e2f.html"/>
    <id>https://hongdouzza.github.io/posts/d68e5e2f.html</id>
    <published>2024-04-16T15:47:33.000Z</published>
    <updated>2024-12-16T13:12:30.705Z</updated>
    
    <content type="html"><![CDATA[<h1 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h1><ul><li>简介</li><li>观察</li><li>数学模型</li><li>增长顺序分类</li><li>算法理论</li><li>内存</li></ul><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>为什么要做算法分析：</p><ul><li>预测性能</li><li>比对算法</li><li>提供保证</li><li>避免性能错误<br>最主要是避免性能bug</li></ul><p>成功算法的例子：FFT<br>快速傅里叶变换（这好像高斯以前手稿提过，认为含金量，故未发表，大物课上有提到）</p><p>暴力算法：n**2<br>FFT：n log n</p><p>当我们做算法分析时，应该考虑程序是否能适应大规模数据。性能是否足够（速度、内存）</p><h2 id="观察"><a href="#观察" class="headerlink" title="观察"></a>观察</h2><p>3-sum:给定n个整型数据，有多少组（每组三个元素）元素和为0</p><p>javac测算运行时间的函数：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span>[] a = In.readInts(args[<span class="number">0</span>]);</span><br><span class="line"> <span class="type">Stopwatch</span> <span class="variable">stopwatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Stopwatch</span>();</span><br><span class="line"> StdOut.println(ThreeSum.count(a));</span><br><span class="line"> <span class="type">double</span> <span class="variable">time</span> <span class="operator">=</span> stopwatch.elapsedTime();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p>我们发现对于不同的数据，程序运行时间大致为a<em>N*</em>b ,b=lg ratio</p><p>其中b的影响因子有：</p><ul><li>算法</li><li>输入数据</li></ul><p>而a的影响因子有：</p><ul><li>硬件：CPU，内存，缓存</li><li>软件:编译器，解释器，垃圾回收器</li><li>系统：操作系统、网路、其他app</li><li>以及算法和输入数据</li></ul><p>这很精确得到测量，但对比其他科学更便宜更方便</p><h2 id="数学模型"><a href="#数学模型" class="headerlink" title="数学模型"></a>数学模型</h2><p>运行时间：所有操作的成本*频率之和</p><ul><li>需要分析程序去决定操作集</li><li>成本取决于机器、编译器</li><li>频率取决于算法和输入数据</li></ul><p>不同的operation的运行的h时间是不同的（加减乘除、浮点数整数都不一样）</p><p>字符串的连接通常耗费很多时间，切勿滥用</p><p>“ It is convenient to have a measure of the amount of work involved<br> in a computing process, even though it be a very crude one. We may<br> count up the number of times that various elementary operations are<br> applied in the whole process and then given them various weights.<br> We might, for instance, count the number of additions, subtractions,<br> multiplications, divisions, recording of numbers, and extractions<br> of figures from tables. In the case of computing with matrices most<br> of the work consists of multiplications and writing down numbers,<br> and we shall therefore only attempt to count the number of<br> multiplications and recordings. “</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;算法分析&quot;&gt;&lt;a href=&quot;#算法分析&quot; class=&quot;headerlink&quot; title=&quot;算法分析&quot;&gt;&lt;/a&gt;算法分析&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;简介&lt;/li&gt;
&lt;li&gt;观察&lt;/li&gt;
&lt;li&gt;数学模型&lt;/li&gt;
&lt;li&gt;增长顺序分类&lt;/li&gt;
&lt;li&gt;算法</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>javaLearning_继承和多态</title>
    <link href="https://hongdouzza.github.io/posts/2006c4c8.html"/>
    <id>https://hongdouzza.github.io/posts/2006c4c8.html</id>
    <published>2024-04-15T11:19:27.000Z</published>
    <updated>2024-12-16T13:12:30.701Z</updated>
    
    <content type="html"><![CDATA[<h1 id="继承和多态"><a href="#继承和多态" class="headerlink" title="继承和多态"></a>继承和多态</h1><ul><li>继承</li><li>多态</li><li>特殊类：抽象类、final类、内部类</li><li>接口</li><li>object类</li><li>垃圾内存回收机制</li></ul><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h3><p>继承：复用已存在类的属性和方法。</p><p>语法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>()&#123;</span><br><span class="line">    String name</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">speak</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">clas Cat <span class="keyword">extends</span> <span class="title class_">Animal</span>()&#123;</span><br><span class="line">    String color;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>java支持单继承，不允许多继承（子类只能有一个父类，类似树），可有多层继承。</p><p>子类继承父类的成员变量和成员方法（private成员也继承，private方法不继承），不继承父类的构造方法。</p><p>函数重写覆盖：子类方法和父类相同，调用子类对象时，子类方法覆盖父类。重写的方法权限不能缩小。</p><p>final方法不能被重写。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;继承和多态&quot;&gt;&lt;a href=&quot;#继承和多态&quot; class=&quot;headerlink&quot; title=&quot;继承和多态&quot;&gt;&lt;/a&gt;继承和多态&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;继承&lt;/li&gt;
&lt;li&gt;多态&lt;/li&gt;
&lt;li&gt;特殊类：抽象类、final类、内部类&lt;/li&gt;
&lt;li&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>并查集作业和一些想法</title>
    <link href="https://hongdouzza.github.io/posts/31b72f78.html"/>
    <id>https://hongdouzza.github.io/posts/31b72f78.html</id>
    <published>2024-04-09T22:02:57.000Z</published>
    <updated>2024-12-16T13:12:30.701Z</updated>
    
    <content type="html"><![CDATA[<h1 id="三个简述题"><a href="#三个简述题" class="headerlink" title="三个简述题"></a>三个简述题</h1><p>ENGLISH</p><p>Q1:Question 1<br><strong>Social network connectivity</strong>. Given a social network containing n members and a log file containing m timestamps at which times pairs of members formed friendships, design an algorithm to determine the earliest time at which all members are connected (i.e., every member is a friend of a friend of a friend … of a friend). Assume that the log file is sorted by timestamp and that friendship is an equivalence relation. The running time of your algorithm should be logm logn or better and use extra space proportional to n.</p><p>A1:We can solve this problem using the weighted quick union algorithm. When initialized, the n members are each in an independent group, and count=n is recorded as the current remaining continuous flux. The weighted union operation is performed each time a log is read, and the remaining continued flux is reduced by 1. When the remaining flux drops to 1, the earliest connection time is the current log time。</p><p>Q2：<strong>Union-find with specific canonical element</strong>. Add a method find() to the<br>find(i) returns the largest element in the connected component containing i. The operations, union(), connected(), and find() should all take logarithmic time or better.For example, if one of the connected components is {1,2,6,9}{1,2,6,9}, then the find method should return 99 for each of the four elements in the connected components.</p><p>A2：We use the weighted quick-union algorithm to solve this problem. When initialized, each data is independent as a group, we define two arrays: arr records the maximum number of each group, arr[i]=i.; sz[i]=1 is the current size of each set of trees. Update arr[Root node of a larger tree] =max(arr[root(p)],arr[root(q)]) when performing the union operation, that is, when connecting a small tree to a large tree. When performing the find (i) operation, return the value of arr[root(i)]</p><p>Q3：<strong>Successor with delete</strong>.Given a set of n integers ={0,1,…,N-1}.S={0,1,…,n−1} and a sequence of requests of the following form:</p><ul><li>Remove x from S</li><li>Find the successor of x: the smallest y in S such that y≥x.</li></ul><p>design a data type so that all operations (except construction)  take logarithmic time or better in the worst case.</p><p>A3:We use quick-union with compression. Design two arrays: parent[], to record the data set, initialized with each element pointing to itself; next[] Record the next successsor for i. When remove x from s is executed, the collection to which x belongs is first pointed to next[next[i]] by uinon(x, next[i]). We optimize the algorithm with path compression when merging the two collections. When we find the current successor to x, return the value next[root[x]]. So we’re going to have a logarithmic complexity</p><h1 id="通过并查集模拟渗流问题（ddl-4-14）"><a href="#通过并查集模拟渗流问题（ddl-4-14）" class="headerlink" title="通过并查集模拟渗流问题（ddl: 4.14）"></a>通过并查集模拟渗流问题（ddl: 4.14）</h1><p>这是Coursera留下的并查集大作业</p><p>渗流模型简述：在给定的n*n网格中，每一个格点有三个状态（关、开、充满水），当水流自上而下能够流通网格时（水的流通方向为上下左右），该模型处于渗流状态。</p><p>问题简述：数学家发现当每个格点打开的概率为p,存在一个阈值p<em> ，当n最足够大时，所有p&gt;p</em> 的模型几乎都处于渗流，而所有p&lt;p<em> 的模型几乎处于阻塞状态。然而数学家无法运用数理方法准确估计p</em> 的值。现在我们在计算机上设计程序模拟该p*。 <img src="/source/_posts/image.png" alt="Alt text"></p><p>设置头部虚拟节点(topsite)和尾部虚拟节点(tailsite)，当topsite和tailsite连通时，改模型为渗流状态。头部虚拟节点相当于水源，尾部虚拟节点相当于水桶。当水桶里有水了，说明模型处于渗流状态。</p><p>使用weighted quick-union算法解决，当然直接用迭代判断渗流也可，但算法时间复杂度高于前者</p><p>提交的percplation.zip 包含 percolation.java、percolationStats.java</p><p>percolation.java：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> edu.princeton.cs.algs4.WeightedQuickUnionUF;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Percolation</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="type">boolean</span>[][] grid;</span><br><span class="line">   <span class="keyword">private</span> WeightedQuickUnionUF uf;</span><br><span class="line">    <span class="keyword">private</span>  <span class="type">int</span> topsite;</span><br><span class="line">    <span class="keyword">private</span>  <span class="type">int</span> bottomsite;</span><br><span class="line">    <span class="keyword">private</span>  <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建n*n的网格（grid），初始化时所有格点为闭塞状态（false）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Percolation</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;the n is outside&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.n=n;</span><br><span class="line">        uf =<span class="keyword">new</span> <span class="title class_">WeightedQuickUnionUF</span>(n*n+<span class="number">2</span>);</span><br><span class="line">        topsite=n*n;</span><br><span class="line">        bottomsite=n*n+<span class="number">1</span>;</span><br><span class="line">        grid=<span class="keyword">new</span> <span class="title class_">boolean</span>[n][n];</span><br><span class="line">        <span class="built_in">this</span>.n=n;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开指定格点，并且连接四周以开放的格点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> col)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(row&lt;<span class="number">0</span>||row&gt;n-<span class="number">1</span>||col&lt;<span class="number">0</span>||col&gt;n-<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;the row/col is outside&quot;</span>);</span><br><span class="line">        <span class="type">int</span> [][] direction=&#123;&#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">if</span>(!grid[row][col])&#123;</span><br><span class="line">            grid[row][col]=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(row==<span class="number">0</span>)&#123;</span><br><span class="line">                uf.union(encode(row,col),topsite);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(row==n-<span class="number">1</span>)</span><br><span class="line">            &#123;uf.union(row*n+col,bottomsite);</span><br><span class="line">                grid[row][col]=<span class="literal">true</span>;&#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span>[] d:direction)&#123;</span><br><span class="line">                <span class="type">int</span> addrow=row+d[<span class="number">0</span>];</span><br><span class="line">                <span class="type">int</span> addcol=col+d[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>(addrow&gt;=<span class="number">0</span>&amp;&amp;addcol&lt;=n-<span class="number">1</span>&amp;&amp;addcol&gt;=<span class="number">0</span>&amp;&amp;addcol&lt;=n-<span class="number">1</span>&amp;&amp;isOpen(addrow,addcol))&#123;</span><br><span class="line">                    uf.union(encode(row,col),encode(addrow,addcol));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断格点是否为打开状态</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isOpen</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> col)</span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(row&lt;<span class="number">0</span>||row&gt;<span class="built_in">this</span>.n-<span class="number">1</span>||col&lt;<span class="number">0</span>||col&gt;<span class="built_in">this</span>.n-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//throw new IllegalArgumentException(&quot;the row/col is outside&quot;);</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">        <span class="keyword">return</span> grid[row][col];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 过查看格点与头部虚拟节点连判断格点是否为注满水，</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> col)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(row&lt;<span class="number">1</span>||row&gt;n||col&lt;<span class="number">1</span>||col&gt;n)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;the row/col is outside&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> uf.find(encode(row,col))== uf.find(topsite)&amp;&amp;isOpen(row,col);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录已打开格点的个数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numberOfOpenSites</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(isOpen(i, j)==<span class="literal">true</span>)</span><br><span class="line">                    count++;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过查看bottoemsite是否连通topsite判断模型是否渗流（connected()方法已被弃用了）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">percolates</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> uf.find(topsite)==uf.find(bottomsite);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">encode</span><span class="params">(<span class="type">int</span> row ,<span class="type">int</span> col)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> row*n+col;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// test client (optional)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>percolationStats.java：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> edu.princeton.cs.algs4.StdRandom;</span><br><span class="line"><span class="keyword">import</span> edu.princeton.cs.algs4.StdStats;</span><br><span class="line"><span class="keyword">import</span> edu.princeton.cs.algs4.StdOut;</span><br><span class="line"><span class="keyword">import</span> edu.princeton.cs.algs4.StdIn;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PercolationStats</span> &#123;</span><br><span class="line">   <span class="comment">//x数组存储每次实验的渗流概率</span></span><br><span class="line">    <span class="keyword">private</span>  <span class="type">double</span>[] x;</span><br><span class="line">   <span class="keyword">private</span>  <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">private</span>  <span class="type">int</span> T;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试T次n*n的模型</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PercolationStats</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> trials)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.n=n;</span><br><span class="line">        T=trials;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.n&lt;=<span class="number">0</span>||T&lt;=<span class="number">0</span>)</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;the n/trials is outside&quot;</span>);</span><br><span class="line">        x=<span class="keyword">new</span> <span class="title class_">double</span>[trials];</span><br><span class="line">        <span class="type">int</span> row;</span><br><span class="line">        <span class="type">int</span> col;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;trials;i++)&#123;</span><br><span class="line">            Percolation a=<span class="keyword">new</span> <span class="title class_">Percolation</span>(n);</span><br><span class="line">            <span class="keyword">while</span>(!a.percolates())&#123;</span><br><span class="line">               <span class="keyword">do</span>&#123;</span><br><span class="line">                row=StdRandom.uniformInt(n);</span><br><span class="line">                col=StdRandom.uniformInt(n);&#125;<span class="keyword">while</span> (a.isOpen(row,col));</span><br><span class="line">                a.open(row,col);</span><br><span class="line"></span><br><span class="line">            &#125;;</span><br><span class="line">            x[i]=a.numberOfOpenSites()/(<span class="type">double</span>)(n*n);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sample mean of percolation threshold</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">mean</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="type">double</span> m;</span><br><span class="line">            m=StdStats.mean(x);</span><br><span class="line">            <span class="keyword">return</span> m;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sample standard deviation of percolation threshold</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">stddev</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">double</span> s;</span><br><span class="line">            s=StdStats.stddev(x);</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// low endpoint of 95% confidence interval</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">confidenceLo</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="type">double</span> c;</span><br><span class="line">            <span class="type">double</span> s=StdStats.stddev(x);</span><br><span class="line">            c=StdStats.mean(x)-<span class="number">1.96</span>*s/Math.sqrt(T);</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// high endpoint of 95% confidence interval</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">confidenceHi</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">double</span> c;</span><br><span class="line">        <span class="type">double</span> s=StdStats.stddev(x);</span><br><span class="line">        c=StdStats.mean(x)+<span class="number">1.96</span>*s/Math.sqrt(T);</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// test client (see below)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line">        <span class="type">int</span> T;</span><br><span class="line">        n=StdIn.readInt();</span><br><span class="line">        T=StdIn.readInt();</span><br><span class="line">        PercolationStats m=<span class="keyword">new</span> <span class="title class_">PercolationStats</span>(n,T);</span><br><span class="line">        StdOut.println(<span class="string">&quot;mean                    = &quot;</span>+m.mean());</span><br><span class="line">        StdOut.println(<span class="string">&quot;stddev                  = &quot;</span>+m.stddev());</span><br><span class="line">        StdOut.println(<span class="string">&quot;95% confidence interval = [&quot;</span>+m.confidenceLo()+<span class="string">&quot;,&quot;</span>+m.confidenceHi()+<span class="string">&quot;]&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;三个简述题&quot;&gt;&lt;a href=&quot;#三个简述题&quot; class=&quot;headerlink&quot; title=&quot;三个简述题&quot;&gt;&lt;/a&gt;三个简述题&lt;/h1&gt;&lt;p&gt;ENGLISH&lt;/p&gt;
&lt;p&gt;Q1:Question 1&lt;br&gt;&lt;strong&gt;Social network con</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>algorithms1</title>
    <link href="https://hongdouzza.github.io/posts/b3c0369f.html"/>
    <id>https://hongdouzza.github.io/posts/b3c0369f.html</id>
    <published>2024-04-08T13:52:00.000Z</published>
    <updated>2024-12-16T13:12:30.701Z</updated>
    
    <content type="html"><![CDATA[<h1 id="【学习】并查集"><a href="#【学习】并查集" class="headerlink" title="【学习】并查集"></a>【学习】并查集</h1><p>采用princton的Coursera课程：<a href="https://www.coursera.org/learn/algorithms-part1">algorithms1&amp;2</a></p><p>union-find:</p><ul><li>dynamic connecticity</li><li>quick find</li><li>quck union</li><li>improvemnts</li><li>applications</li></ul><h2 id="动态连通性"><a href="#动态连通性" class="headerlink" title="动态连通性"></a>动态连通性</h2><p>union commamd指令: 连接两个对象<br>find/connected query指令： 检查是否有两个对象连通的路径</p><p>应用场景：在编程时，将整数作为数组的索引时<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//以下使用algs4。jar包</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> StdIn.readInt();</span><br><span class="line"> <span class="type">UF</span> <span class="variable">uf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UF</span>(N);</span><br><span class="line"> <span class="keyword">while</span> (!StdIn.isEmpty())</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> StdIn.readInt();</span><br><span class="line"> <span class="type">int</span> <span class="variable">q</span> <span class="operator">=</span> StdIn.readInt();</span><br><span class="line"> <span class="keyword">if</span> (!uf.connected(p, q))</span><br><span class="line"> &#123;</span><br><span class="line"> uf.union(p, q);</span><br><span class="line"> StdOut.println(p + <span class="string">&quot; &quot;</span> + q);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="快速查找-Quick-find"><a href="#快速查找-Quick-find" class="headerlink" title="快速查找(Quick-find)"></a>快速查找(Quick-find)</h2><h3 id="java实现方式"><a href="#java实现方式" class="headerlink" title="java实现方式"></a>java实现方式</h3><p>数据结构：</p><ul><li>长度为N的整数数组 id[]</li><li>当且仅当p和q的id值相同，表示p和q连通<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuickFind</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] id;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">QuickFind</span><span class="params">(<span class="type">int</span> N)</span>&#123;</span><br><span class="line">        id=<span class="keyword">new</span> <span class="title class_">int</span>[N];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">            id[i]=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">connected</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> q)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id[p]==id[q];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Union</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> q)</span>&#123;</span><br><span class="line">        <span class="type">int</span> pid=id[p];</span><br><span class="line">        <span class="type">int</span> qid=id[q];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;id.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(id[i]==pid)&#123;</span><br><span class="line">                id[i]=qid;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a>算法分析：</h3>快速查找too slow？</li><li>cost model: 初始化、union都需要遍历整个数组，复杂度正比于N；查找很快,复杂度为常数</li><li>union太expensive:N**2的复杂度</li></ul><h2 id="快速并集（Quick-union-lazy-approach-）"><a href="#快速并集（Quick-union-lazy-approach-）" class="headerlink" title="快速并集（Quick-union [lazy approach]）"></a>快速并集（Quick-union [lazy approach]）</h2><p>数据结构：树型</p><ul><li>长度为N的整数数组 id[]</li><li>id[i]时id的父节点</li><li>i的root节点为id[id[id[…id[i]…]]]</li></ul><p>对象连通? 判断p和q的根节点是否相同</p><p>集合：当连接两个对象p,q，设置p的根节点为q根节点的id</p><p>java实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QucikUnion</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] id;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">QucikUnion</span><span class="params">(<span class="type">int</span> N)</span>&#123;</span><br><span class="line">        id=<span class="keyword">new</span> <span class="title class_">int</span>[N];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">            id[i]=i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">root</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(id[i]!=i)&#123;</span><br><span class="line">            i=id[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">connected</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> q)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root(p)==root(q);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> q)</span>&#123;</span><br><span class="line">        id[root(p)]=id[root(q)];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>然而quick-union算法也无法适应大规模数据<br>cost model:</p><div class="table-container"><table><thead><tr><th style="text-align:left">algorithm</th><th style="text-align:left">initialize</th><th style="text-align:left">union</th><th style="text-align:left">find</th></tr></thead><tbody><tr><td style="text-align:left">quick-find</td><td style="text-align:left">N</td><td style="text-align:left">N</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">quick-union</td><td style="text-align:left">N</td><td style="text-align:left">N(包含找根节点)</td><td style="text-align:left">N</td></tr></tbody></table></div><p>我们对比快速查找和快速并集，不难发现各自的缺陷</p><p>快速查找:</p><ul><li>并集费时（N）</li><li>树是平展的，但维持平铺的状态需要费时（怎么理解？）</li></ul><p>快速并集：</p><ul><li>树高</li><li>查找费时（N）</li></ul><p>所以，我们接下来对并查做一些改进。</p><h2 id="加权快速并集（Weighted-quick-union）和压缩路径快速并集-Quick-union-with-path-compression"><a href="#加权快速并集（Weighted-quick-union）和压缩路径快速并集-Quick-union-with-path-compression" class="headerlink" title="加权快速并集（Weighted quick-union）和压缩路径快速并集(Quick union with path compression)"></a>加权快速并集（Weighted quick-union）和压缩路径快速并集(Quick union with path compression)</h2><p>我们跟踪记录生成树的大小（包含对象的个数），将其作为权。并集的时候，权轻的树根节点改为权重的根节点。换句话说，就是小树接到大树下，而非前树接到后树下。这样降低所有节点到根节点的平均距离，并且避免树过深的的算法叫<strong>加权快速并查</strong></p><h2 id="加权快速并查"><a href="#加权快速并查" class="headerlink" title="加权快速并查"></a>加权快速并查</h2><p>数据结构：与快速查找相同，<strong>增加sz[i]存储以i为根节点的树的大小（树下包含对象的数量）</strong></p><p>并集：小树接到大树下，实时更新sz[i]<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QucikUnion</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] id;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">QucikUnion</span><span class="params">(<span class="type">int</span> N)</span>&#123;</span><br><span class="line">        id=<span class="keyword">new</span> <span class="title class_">int</span>[N];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">            id[i]=i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">root</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(id[i]!=i)&#123;</span><br><span class="line">            i=id[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">connected</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> q)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root(p)==root(q);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> q)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sz[p]&gt;sz[q])</span><br><span class="line">          &#123;id[root(q)]=root(p);</span><br><span class="line">          sz[p]+=sz[q];</span><br><span class="line">          &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          &#123;id[root(p)]=root(q);</span><br><span class="line">          sz[q]+=sz[p];</span><br><span class="line">          &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>算法分析：</p><p>1.<strong>运行时间的分析</strong>：</p><ul><li>查找：时间和p、q的深度成正比</li><li>并集：时间为常量</li></ul><p>2.<strong>任意节点X最大为lgN</strong></p><p>以下为简答的数学证明（注意：在计算机领域，lgN底数为2）：</p><ol><li><p><strong>定义</strong>：令(N)表示节点总数，(T_i)表示进行了(i)次并集操作后的某个树的大小（节点数），(h_i)表示这个树的高度（即树中任意节点的最大深度）。</p></li><li><p><strong>观察</strong>：在加权快速并集中，每次并集操作都是将一个较小的树连接到一个较大的树上。因此，每次树的大小至少翻倍（对原先的小树而言）。</p></li><li><p><strong>数学归纳</strong>：</p><ul><li><strong>基础情况</strong>：当树大小(T = 1)时，高度(h = 0)，满足(h \leq \lg T)。</li><li><strong>归纳步骤</strong>：假设对于树的大小为(T<em>k)时，其高度(h_k \leq \lg T_k)成立。当执行一次并集操作，将一个大小至少为(T_k)的树连接到另一个大小至少为(T_k)的树上时，结果树的大小至少为(2T_k)，因此新树的高度(h</em>{k+1} = h_k + 1)（因为最多增加一层）。</li></ul></li><li><p><strong>证明</strong>：根据归纳步骤，新的高度(h<em>{k+1} \leq \lg T_k + 1 = \lg (2T_k)(完全二叉树时) = \lg T</em>{k+1})。这证明了在任意时刻，树的高度（深度）(h)总是小于等于(\lg N)，其中(N)是节点总数。</p></li></ol><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>因此，我们可以得出结论，在加权快速并集算法中，任何节点(x)的深度最大为(\lg N)。这个性质保证了查找操作的高效性，因为查找路径长度的上限是对数级别的。</p><div class="table-container"><table><thead><tr><th style="text-align:left">algorithm</th><th style="text-align:left">initialize</th><th style="text-align:left">union</th><th style="text-align:left">find</th></tr></thead><tbody><tr><td style="text-align:left">quick-find</td><td style="text-align:left">N</td><td style="text-align:left">N</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">quick-union</td><td style="text-align:left">N</td><td style="text-align:left">N(包含找根节点)</td><td style="text-align:left">N</td></tr><tr><td style="text-align:left">weighted</td><td style="text-align:left">N</td><td style="text-align:left">lgN(包含找根节点)</td><td style="text-align:left">lgN</td></tr></tbody></table></div><p>我们还可以进一步优化</p><h2 id="路径压缩快速并集"><a href="#路径压缩快速并集" class="headerlink" title="路径压缩快速并集"></a>路径压缩快速并集</h2><p>在快速并集时，在找到根节点时，将之前的检查点重新直接指向根节点，这样压缩了之后的检查路径的算法叫<strong>路径压缩快速并集（Quick union with path compression）</strong></p><p>java实现方式<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">root</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(id[i]!=i)&#123;</span><br><span class="line">        id[i]=id[id[i]];</span><br><span class="line">        i=id[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>但还可以进一步优化算法。</p><h2 id="集大成的玩意儿"><a href="#集大成的玩意儿" class="headerlink" title="集大成的玩意儿"></a>集大成的玩意儿</h2><p>怎么优化呢？</p><p>很简单，加权和路径压缩搅一块儿就好啦。所以诞生了这么个玩意儿。<br><strong>Weighted</strong> quick-union <strong>with path compression</strong>!!</p><p>接下来简单介绍对其平摊分析</p><h3 id="平摊分析（Amortized-analysis）"><a href="#平摊分析（Amortized-analysis）" class="headerlink" title="平摊分析（Amortized analysis）"></a><strong>平摊分析（Amortized analysis）</strong></h3><p>Q:什么是平摊分析？<br>A:是用于算法分析的方法。在使用平摊分析前须知道数据结构<strong>各种操作所可能发生的时间</strong>，并计算出<strong>最坏情况下</strong>的操作情况并加以平均。能够确认<strong>最坏情况性能的每次操作耗费的平均时间</strong>，但不能确认平均情况性能。（from wikipedia）</p><p>1.<strong>Hopcroft-Ulman, Tarjan</strong> 提出：从一个空的数据结构开始，对N个对象执行M次并查集操作（包括查找和合并）最多需要 c<em>(N + M \lg</em> N) 次数组访问。其中，lg<em> N 是迭代对数函数，表示需要多少次迭代对数运算才能使N减少到1以下。这是一个增长非常缓慢的函数，对于所有实际的N值，lg^</em> N 都是一个非常小的常数。如下：</p><ul><li>当 N = 1 时，lg^* N = 0</li><li>当 N = 2 时，lg^* N = 1</li><li>当 N 增加到16时，lg^* N = 3</li><li>直到 N = 65536 时，lg^* N 才变成4</li></ul><p>2.分析可以进一步改进为 N + M \alpha(M, N)，其中 alpha(M, N) 是阿克曼函数的逆函数，也是一个非常慢增长的函数。这表明在实际应用中，加权快速合并算法（Weighted Quick-Union）配合路径压缩（Path Compression，简称WQUPC）的性能非常接近线性时间。</p><p>3.线性时间算法问题：对于M次并查集操作在N个对象上，是否存在线性时间算法？理论上，基于加权快速合并与路径压缩的分析（WQUPC），并不是严格的线性时间。</p><ul><li>然而，实际上，这个算法的性能非常接近线性时间，考虑到数据输入的成本，其代价在常数因子范围内。</li></ul><h3 id="Amazing-Fact"><a href="#Amazing-Fact" class="headerlink" title="Amazing Fact"></a>Amazing Fact</h3><p>！！</p><ul><li><strong>Fredman-Saks</strong> 提出的惊人事实：<strong>不存在严格的线性时间算法</strong>。即便是WQUPC算法，也不能在理论上达到完全的线性时间复杂度。</li></ul><h3 id="WQUPC"><a href="#WQUPC" class="headerlink" title="WQUPC"></a>WQUPC</h3><p>WQUPC通过维护子树大小并在执行查找操作时压缩路径来优化合并操作，使得后续的查找操作更高效。通过这种方式，算法的平均时间复杂度<strong>非常接近线性</strong>，尽管在最坏情况下并非完全线性，但在实际应用中表现出色。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><div class="table-container"><table><thead><tr><th style="text-align:left">algorithm</th><th style="text-align:left">worst-case time</th></tr></thead><tbody><tr><td style="text-align:left">quick-find</td><td style="text-align:left">M N</td></tr><tr><td style="text-align:left">weighted QU</td><td style="text-align:left">M N</td></tr><tr><td style="text-align:left">weighted QU</td><td style="text-align:left">N + M log N</td></tr><tr><td style="text-align:left">QU+compression</td><td style="text-align:left">N + M log N</td></tr><tr><td style="text-align:left">WQUPC</td><td style="text-align:left">N+ M lg*N</td></tr></tbody></table></div><p>事实证明，超级计算机靠暴力无法解决的，超级算法可以</p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>大致应用场景直接抄PPT上的内容了，这块主要讲的是渗流问题</p><ul><li>渗流</li><li>游戏（围棋，Hex）</li><li>动态连通性</li><li>最小公共祖先</li><li>有限状态自动机的等价性</li><li>物理中的Hoshen-Kopelman算法</li><li>Hinley-Milner多态类型推断</li><li>Kruskal’s最小生成树算法</li><li>Fortran中编译等价语句</li><li>形态学属性的开启和关闭</li><li>图像处理中Matlab的bwlabel()函数</li></ul><p>渗流问题Coursera留了一个大作业，下篇具体写</p><h2 id="全篇总结"><a href="#全篇总结" class="headerlink" title="全篇总结"></a>全篇总结</h2><p>并查集主要解决的是动态连通性问题，为了优化算法引入了树模型作为对象连通结构。那么普通的quick-union在面临大规模数据可能遇到两个问题：树过高，路径过长；于是我们分别用加权和路径压缩算法加以解决，最后尝试将加权和路径压缩搅在一起成了本集顶级战力WQUPC。</p><p>接下来要滚去写大作业力</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;【学习】并查集&quot;&gt;&lt;a href=&quot;#【学习】并查集&quot; class=&quot;headerlink&quot; title=&quot;【学习】并查集&quot;&gt;&lt;/a&gt;【学习】并查集&lt;/h1&gt;&lt;p&gt;采用princton的Coursera课程：&lt;a href=&quot;https://www.courser</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>java学习记录2</title>
    <link href="https://hongdouzza.github.io/posts/fd87d377.html"/>
    <id>https://hongdouzza.github.io/posts/fd87d377.html</id>
    <published>2024-04-08T10:45:38.000Z</published>
    <updated>2024-12-16T13:12:30.701Z</updated>
    
    <content type="html"><![CDATA[<h1 id="【JAVA学习笔记2】-数组和java常用类"><a href="#【JAVA学习笔记2】-数组和java常用类" class="headerlink" title="【JAVA学习笔记2】 数组和java常用类"></a>【JAVA学习笔记2】 数组和java常用类</h1><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组的概念：</p><ul><li>一维数组</li><li>二维数组</li><li>Arrays类</li><li>包装类</li><li>字符串类<br>集合类</li></ul><p>数组长度不可变</p><h2 id="对象数组"><a href="#对象数组" class="headerlink" title="对象数组"></a>对象数组</h2><p>数组初始化：int[]x={1,2,3,4};  (静态初始化)<br>声明时不能指定数组长度<br>动态初始化：int []x=new int[12];</p><p>垃圾内存（释放）</p><p>for each语句<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> []a=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i:arr)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>好像没什么好写的，数组这块很简单….</p><h2 id="包"><a href="#包" class="headerlink" title="包"></a>包</h2><h2 id="字符串类"><a href="#字符串类" class="headerlink" title="字符串类"></a>字符串类</h2><p>string：常量 stringbuffer stringbuilder：变量</p><p>定义字符串：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//int无法转char</span></span><br><span class="line"><span class="type">int</span> b[]=&#123;&#125;</span><br></pre></td></tr></table></figure></p><p>int length方法</p><p>String toLowerCase()<br>String toUpperCase()</p><p>String类</p><p>字符串比大小（equals()）<br>==: 比的是地址</p><p>可变字符串:<br>append()</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;【JAVA学习笔记2】-数组和java常用类&quot;&gt;&lt;a href=&quot;#【JAVA学习笔记2】-数组和java常用类&quot; class=&quot;headerlink&quot; title=&quot;【JAVA学习笔记2】 数组和java常用类&quot;&gt;&lt;/a&gt;【JAVA学习笔记2】 数组和java常</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Mysql学习记录1</title>
    <link href="https://hongdouzza.github.io/posts/52057b56.html"/>
    <id>https://hongdouzza.github.io/posts/52057b56.html</id>
    <published>2024-04-01T14:59:12.000Z</published>
    <updated>2024-12-16T13:12:30.701Z</updated>
    
    <content type="html"><![CDATA[<p>这不是mysql学习记录<br>这是mysql<strong>重装记录</strong>。。。。。。<br>半年前装的mysql，密码忘了。开管理员权限怎么也无法跳过密码（纯怨种）。看了日志，说mysql配置出了问题，还可能数据损坏了….这怎么问题越挖越多。咱就是说人越菜，挖的坑越多。</p><p>准备重装了，原来卸载也比较繁琐：删库、删注册表、删软件</p><p>明天重装了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这不是mysql学习记录&lt;br&gt;这是mysql&lt;strong&gt;重装记录&lt;/strong&gt;。。。。。。&lt;br&gt;半年前装的mysql，密码忘了。开管理员权限怎么也无法跳过密码（纯怨种）。看了日志，说mysql配置出了问题，还可能数据损坏了….这怎么问题越挖越多。咱就是说人越菜，</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>阶段随笔</title>
    <link href="https://hongdouzza.github.io/posts/8cc9c8aa.html"/>
    <id>https://hongdouzza.github.io/posts/8cc9c8aa.html</id>
    <published>2024-03-31T18:27:56.000Z</published>
    <updated>2024-12-16T13:12:30.705Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第四周"><a href="#第四周" class="headerlink" title="第四周"></a>第四周</h1><p>之前的事基本告一段落</p><ul><li>藤廊演出还算成功，合奏选曲不合适。每次演出后都很高兴，都有新的朋友</li><li>互联网+成功提桶跑路，不想多说什么，懒得喷（组织架构过于松散）</li><li>养成写博客习惯，挺好</li><li>下个阶段：录制WAGF和吉他中国比赛的视频；把之前写的一些riff、demo发展成完整的曲目</li><li>下周：物理学人类文明PPT、C语言大作业</li><li>幽梦影、词与物读完</li><li>开始学sql数据库知识</li><li>坚持跑步健身！！</li></ul><p>4.2号：<br>我再也不魔改博客了(:cry:),音乐馆给炸了，哈哈哈。算了明天改回aplayer吸底，属于装修走火入魔了。我今天都不敢部署到仓库里（:cold_sweat:）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第四周&quot;&gt;&lt;a href=&quot;#第四周&quot; class=&quot;headerlink&quot; title=&quot;第四周&quot;&gt;&lt;/a&gt;第四周&lt;/h1&gt;&lt;p&gt;之前的事基本告一段落&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;藤廊演出还算成功，合奏选曲不合适。每次演出后都很高兴，都有新的朋友&lt;/li&gt;
&lt;li</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>GO学习记录1</title>
    <link href="https://hongdouzza.github.io/posts/dff1b3b7.html"/>
    <id>https://hongdouzza.github.io/posts/dff1b3b7.html</id>
    <published>2024-03-29T23:43:49.000Z</published>
    <updated>2024-12-16T13:12:30.701Z</updated>
    
    <content type="html"><![CDATA[<h1 id="【Go学习记录】入门"><a href="#【Go学习记录】入门" class="headerlink" title="【Go学习记录】入门"></a>【Go学习记录】入门</h1><p>起步基础先跟着<a href="https://tour.go-zh.org/">Go语言之旅</a><br>基础学习结构：</p><ul><li>包、变量、函数</li><li>流程控制语句</li><li>struct、slice和映射</li><li>方法和接口</li><li>并发</li></ul><h2 id="包、变量、函数"><a href="#包、变量、函数" class="headerlink" title="包、变量、函数"></a>包、变量、函数</h2><ul><li>程序从 main 包开始运行。包名与导入路径的最后一个元素一致。例如，<strong>“math/rand”</strong> 包中的源码均以 <strong>package rand</strong></li><li>尽量分组导入</li><li>一个名字以大写字母开头，那么它就是已导出的。Pizza 就是个已导出名，Pi 也同样，它导出自 math 包。pizza 和 pi 并未以大写字母开头，所以它们是未导出的。在导入一个包时，你只能引用其中已导出的名字。任何 <strong>“未导出”的名字在该包外均无法访问</strong>。</li><li>当连续两个或多个函数的已命名形参类型相同时，除最后一个类型以外，其它都可以省略。如下<code>x int</code>,<code>y int</code>缩写<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li>Go 的返回值可被命名，它们会被视作定义在函数顶部的变量。如下返回了sum<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">split</span><span class="params">(sum <span class="type">int</span>)</span></span> (x, y <span class="type">int</span>) &#123;</span><br><span class="line">x = sum * <span class="number">4</span> / <span class="number">9</span></span><br><span class="line">y = sum - x</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(split(<span class="number">17</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><code>var</code> 语句用于声明一个变量(列表)，跟函数的参数列表一样，类型在最后</li><li><code>:=</code>可在类型明确的地方代替 <code>var</code></li><li><strong>Go 在不同类型的项之间赋值时需要显式转换</strong> </li><li>常量的声明与变量类似，使用 <code>const</code>关键字,不能用 <code>:=</code>语法声明</li></ul><h2 id="流程控制语句"><a href="#流程控制语句" class="headerlink" title="流程控制语句"></a>流程控制语句</h2><ul><li>for循环：Go 的 for 语句后面的三个构成部分外没有小括号<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    sum:=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++&#123;</span><br><span class="line">        sum+=i</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    fmt.Println(sum)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>同样if语句表达式也不需要小括号，同 for 一样， if 语句可以在条件表达式前执行一个简单的语句(<strong>当然作用域只在if大括号内</strong>)。<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pow</span><span class="params">(x, n, lim <span class="type">float64</span>)</span></span> <span class="type">float64</span> &#123;</span><br><span class="line"><span class="keyword">if</span> v := math.Pow(x, n); v &lt; lim &#123;</span><br><span class="line"><span class="keyword">return</span> v</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> lim</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li>defer语句：defer 语句会将函数推迟到<strong>外层函数返回之后执行</strong>（推迟调用的函数<strong>其参数会立即求值</strong>，但直到外层函数返回前该函数都不会被调用），<strong>推迟的函数调用会被压入一个栈（先进后出）中</strong><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;counting&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;done&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>运行结果为<br>counting<br>done<br>9<br>8<br>7<br>6<br>5<br>4<br>3<br>2<br>1<br>0</li></ul><hr><h2 id="struct、slice和映射"><a href="#struct、slice和映射" class="headerlink" title="struct、slice和映射"></a>struct、slice和映射</h2><ul><li>指针：Go的指针保存了值的内存地址。与 C 不同，Go 没有指针运算，其余类似</li><li>结构体指针：有一个指向结构体的指针 <code>p</code>，可通过 <code>(*p).X</code>来访问其字段 <code>X</code>。也可以<strong>隐式间接引用</strong>，直接写 <code>p.X</code></li><li>结构体文法：直接列出字段的值来新分配一个结构体。使用 <code>Name</code>: 语法可以仅列出部分字段。（字段名的顺序无关。）特殊的前缀 &amp; 返回一个指向结构体的指针。<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">X, Y <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">v1 = Vertex&#123;<span class="number">1</span>, <span class="number">2</span>&#125;  <span class="comment">// 创建一个 Vertex 类型的结构体</span></span><br><span class="line">v2 = Vertex&#123;X: <span class="number">1</span>&#125;  <span class="comment">// Y:0 被隐式地赋予</span></span><br><span class="line">v3 = Vertex&#123;&#125;      <span class="comment">// X:0 Y:0</span></span><br><span class="line">p  = &amp;Vertex&#123;<span class="number">1</span>, <span class="number">2</span>&#125; <span class="comment">// 创建一个 *Vertex 类型的结构体（指针）</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(v1, p, v2, v3)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li>数组：<code>var a [10]int</code><h3 id="切片（slice）"><a href="#切片（slice）" class="headerlink" title="切片（slice）"></a>切片（slice）</h3></li><li>切片：GO语言中切片比数组使用更频繁。与Python切片类似，<code>a[low : high]</code>为左闭右开。更改切片的元素会修改其底层数组中对应的元素，与它共享底层数组的切片都会观测到这些修改。</li><li>切片文法：这是一个数组的文法<code>[3]bool&#123;true, true, false&#125;</code><br>现构建一个引用了它的切片：<code>[]bool&#123;true, true, false&#125;</code></li><li>切片长度和容量：切片长度是指自身包含的元素个数，用<code>len()</code>获取;切片容量指的是<strong>切片的第一个元素开始数</strong>，到<strong>其底层数组元素末尾的个数</strong>，用<code>cap()</code>获取</li><li>nil切片：切片的零值是 nil。nil 切片的长度和容量为 0 且没有底层数组。</li><li>用 make 创建切片：切片可以用内建函数 make 来创建，也是创建动态数组的方式。make 函数会分配一个<strong>元素为零值</strong>的数组并返回一个引用了它的切片：<code>a := make([]int, 5)  // len(a)=5</code>要指定它的容量，需向 <code>make</code>传入第三个参数：<code>b := make([]int, 0, 5) /* len(b)=0, cap(b)=5*/    b = b[:cap(b)] /*len(b)=5, cap(b)=5 */  b = b[1:]      /* len(b)=4, cap(b)=4  */</code></li><li>切片可嵌套</li><li><p>append():为切片追加新的元素<code>func append(s []T, vs ...T) []T</code> append的第一个参数 <code>s</code>是一个元素类型为 T 的切片，其余类型为 T 的值将会追加到该切片的末尾。<strong>当 s 的底层数组太小，不足以容纳所有给定的值时，它就会分配一个更大的数组。返回的切片会指向这个新分配的数组。</strong>如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> s []<span class="type">int</span></span><br><span class="line">printSlice(s)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加一个空切片</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">0</span>)</span><br><span class="line">printSlice(s)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个切片会按需增长</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">1</span>)</span><br><span class="line">printSlice(s)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以一次性添加多个元素</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">printSlice(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printSlice</span><span class="params">(s []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;len=%d cap=%d %v\n&quot;</span>, <span class="built_in">len</span>(s), <span class="built_in">cap</span>(s), s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>Range:直接上code(切片这块基本和Python使用相同)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pow = []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">16</span>, <span class="number">32</span>, <span class="number">64</span>, <span class="number">128</span>&#125;</span><br><span class="line"><span class="comment">//第一个值(i)为当前元素的下标，第二个值(v)为该下标所对应元素的一份副本。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> pow &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;2**%d = %d\n&quot;</span>, i, v)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">pow := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">10</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> pow &#123;</span><br><span class="line">pow[i] = <span class="number">1</span> &lt;&lt; <span class="type">uint</span>(i) <span class="comment">// == 2**i</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, value := <span class="keyword">range</span> pow &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%d\n&quot;</span>, value)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h3 id="映射-map"><a href="#映射-map" class="headerlink" title="映射(map)"></a>映射(map)</h3><p>映射将键映射到值。映射的零值为 nil 。<strong>nil 映射既没有键，也不能添加键</strong>。make 函数会返回给定类型的映射，并将其初始化备用。</p><p>映射文法与结构体类似，但要有键名：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">Lat, Long <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> m = <span class="keyword">map</span>[<span class="type">string</span>]Vertex&#123;</span><br><span class="line"><span class="string">&quot;Bell Labs&quot;</span>: Vertex&#123;</span><br><span class="line"><span class="number">40.68433</span>, <span class="number">-74.39967</span>,</span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">&quot;Google&quot;</span>: Vertex&#123;</span><br><span class="line"><span class="number">37.42202</span>, <span class="number">-122.08408</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>修改映射：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line"></span><br><span class="line">m[<span class="string">&quot;Answer&quot;</span>] = <span class="number">42</span></span><br><span class="line">fmt.Println(<span class="string">&quot;The value:&quot;</span>, m[<span class="string">&quot;Answer&quot;</span>])</span><br><span class="line"></span><br><span class="line">m[<span class="string">&quot;Answer&quot;</span>] = <span class="number">48</span></span><br><span class="line">fmt.Println(<span class="string">&quot;The value:&quot;</span>, m[<span class="string">&quot;Answer&quot;</span>])</span><br><span class="line"></span><br><span class="line"><span class="built_in">delete</span>(m, <span class="string">&quot;Answer&quot;</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;The value:&quot;</span>, m[<span class="string">&quot;Answer&quot;</span>])</span><br><span class="line"></span><br><span class="line">v, ok := m[<span class="string">&quot;Answer&quot;</span>]</span><br><span class="line">fmt.Println(<span class="string">&quot;The value:&quot;</span>, v, <span class="string">&quot;Present?&quot;</span>, ok)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>函数的包：Go 函数可以是一个闭包。闭包是一个函数值，它引用了其函数体之外的变量。该函数可以访问并赋予其引用的变量的值，换句话说，该函数被这些变量“绑定”在一起。</p><h2 id="方法和接口"><a href="#方法和接口" class="headerlink" title="方法和接口"></a>方法和接口</h2><p>方法是比较简单的，实际上跟类是一个应用（有方法接受对象的函数）；接口有点难。</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>Go没有类：但可以为结构体类型定义<strong>方法</strong>。方法就是一类带特殊的 <strong>接收者</strong>参数的函数。方法接收者在它自己的参数列表内，位于 func 关键字和方法名之间。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span>&#123;</span><br><span class="line">X, Y <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Vertex)</span></span> Abs() <span class="type">float64</span> &#123;</span><br><span class="line"><span class="keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">v := Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">fmt.Println(v.Abs())</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//也可为非结构体类型声明方法（只能在同一包内定义的类型的接收者声明方法，而不能为其它包内定义的类型（包括 int 之类的内建类型）的接收者声明方法。）</span></span><br><span class="line"><span class="keyword">type</span> MyFloat <span class="type">float64</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f MyFloat)</span></span> Abs() <span class="type">float64</span> &#123;</span><br><span class="line"><span class="keyword">if</span> f &lt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="type">float64</span>(-f)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="type">float64</span>(f)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>为指针接收者声明方法：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">X, Y <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Vertex)</span></span> Abs() <span class="type">float64</span> &#123;</span><br><span class="line"><span class="keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Vertex)</span></span> Scale(f <span class="type">float64</span>) &#123;</span><br><span class="line">v.X = v.X * f</span><br><span class="line">v.Y = v.Y * f</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">v := Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">v.Scale(<span class="number">10</span>)</span><br><span class="line">fmt.Println(v.Abs())</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>由于方法经常需要修改它的接收者，<strong>指针接收者</strong>比<strong>值接收者</strong>更常用。若使用<strong>值接收者</strong>，那么 Scale 方法会对原始 Vertex 值的<strong>副本</strong>进行操作。Scale 方法必须用指针接受者来更改<strong>main 函数中声明的 Vertex 的值</strong>。</p><p>针对指针的函数与方法：</p><ul><li><strong>带指针参数的函数</strong>必须接受一个指针<br><code>var v Vertex  ScaleFunc(v, 5)  // 编译错误！ScaleFunc(&amp;v, 5) // OK</code></li><li>以<strong>指针为接收者的方法</strong>被调用时，接收者<strong>既能为值又能为指针</strong>：<br><code>var v Vertexv.Scale(5)  // OK   p := &amp;v   p.Scale(10) // OK</code><br>所以一般情况下，Go 会将语句 <code>v.Scale(5)</code>解释为 <code>(&amp;v).Scale(5)</code></li></ul><p>所以选择指针为方法接收者的原因有这些：</p><ul><li>方法能够<strong>直接</strong>修改其接收者指向的值</li><li>避免在每次调用方法时<strong>复制</strong>该值。若值的类型为大型结构体时，这样做会更加高效</li></ul><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>接口类型是由<strong>一组方法签名定义的集合</strong>。<br>接口与隐式实现：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">type</span> I <span class="keyword">interface</span> &#123;</span><br><span class="line">M()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">S <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此方法表示类型 T 实现了接口 I，但我们无需显式声明此事。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t T)</span></span> M() &#123;</span><br><span class="line">fmt.Println(t.S)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> i I = T&#123;<span class="string">&quot;hello&quot;</span>&#125;</span><br><span class="line">i.M()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p>接口值：可以像其它值一样传递，可用作函数的参数或返回值。接口值可以看做包含值和具体类型的元组：<code>(value, type)</code><strong>接口值调用方法时会执行其底层类型的同名方法。</strong>(如上例中i调用M()方法执行的是对T的方法)<br>底层为nil接口值：即便接口内的具体值为 nil，方法仍然会被 nil 接收者调用。如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> I <span class="keyword">interface</span> &#123;</span><br><span class="line">M()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">S <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *T)</span></span> M() &#123;</span><br><span class="line"><span class="keyword">if</span> t == <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;&lt;nil&gt;&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(t.S)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> i I</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> t *T</span><br><span class="line">i = t</span><br><span class="line">describe(i)</span><br><span class="line">i.M()</span><br><span class="line"></span><br><span class="line">i = &amp;T&#123;<span class="string">&quot;hello&quot;</span>&#125;</span><br><span class="line">describe(i)</span><br><span class="line">i.M()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>然而nil 接口值既不保存值也不保存具体类型。为 nil 接口调用方法会产生运行时错误。如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> I <span class="keyword">interface</span> &#123;</span><br><span class="line">M()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> i I</span><br><span class="line">describe(i)</span><br><span class="line">i.M()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//i接口的元组内并未包含能够指明该调用哪个 具体 方法的类型</span></span><br></pre></td></tr></table></figure></p><p>空接口：指定了零个方法的接口值<code>interface&#123;&#125;</code>空接口可保存任何类型的值。（因为每个类型都至少实现了零个方法。）空接口被用来处理未知类型的值。常见使用方法：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">describe(i)</span><br><span class="line"></span><br><span class="line">i = <span class="number">42</span></span><br><span class="line">describe(i)</span><br><span class="line"></span><br><span class="line">i = <span class="string">&quot;hello&quot;</span></span><br><span class="line">describe(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">describe</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;(%v, %T)\n&quot;</span>, i, i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>类型断言：提供了访问接口值底层具体值的方式；判断一个接口值是否保存了一个特定的类型，类型断言可返回两个值：其<strong>底层值</strong>以及一个<strong>报告断言是否成功的布尔值</strong>。<code>t, ok := i.(T)</code>(若 i 保存了一个 T，那么 t 将会是其底层值，而 ok 为 true;否则，ok为false而t为T类型的零值)。<strong>类型断言语法和读取一个映射时有相同之处</strong></p><p>类型选择：是一种按顺序从几个类型断言中选择分支的结构。类型选择与一般的 switch 语句相似，不过类型选择中的 case 为类型（而非值）， 它们针对给定接口值所存储的值的类型进行比较。其声明与类型断言 <code>i.(T)</code>的语法相同，<code>T</code>被替换成了关键字 <code>type</code>。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">do</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line"><span class="keyword">switch</span> v := i.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="type">int</span>:</span><br><span class="line">fmt.Printf(<span class="string">&quot;Twice %v is %v\n&quot;</span>, v, v*<span class="number">2</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="type">string</span>:</span><br><span class="line">fmt.Printf(<span class="string">&quot;%q is %v bytes long\n&quot;</span>, v, <span class="built_in">len</span>(v))</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Printf(<span class="string">&quot;I don&#x27;t know about type %T!\n&quot;</span>, v)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">do(<span class="number">21</span>)</span><br><span class="line">do(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">do(<span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>三个常用接口（包）：</p><ul><li>Stringer</li><li>reader</li><li>image</li></ul><p>Stringer：fmt 包中定义的 Stringer 是最普遍的接口之一。它可以用字符串描述自己的类型。fmt 包（还有很多包）都通过此接口来打印值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Stringer <span class="keyword">interface</span> &#123;</span><br><span class="line">    String() <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Reader:<code>io</code>包指定了 <code>io.Reader</code>接口，它表示从数据流的末尾进行读取。<code>io.Reader</code>接口有一个 Read 方法：<code>func (T) Read(b []byte) (n int, err error)</code>;Read 用数据填充给定的字节切片并返回填充的字节数和错误值。在遇到数据流的结尾时，它会返回一个 io.EOF 错误。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;io&quot;</span></span><br><span class="line"><span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">r := strings.NewReader(<span class="string">&quot;Hello, Reader!&quot;</span>)</span><br><span class="line"></span><br><span class="line">b := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">8</span>)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">n, err := r.Read(b)</span><br><span class="line">fmt.Printf(<span class="string">&quot;n = %v err = %v b = %v\n&quot;</span>, n, err, b)</span><br><span class="line">fmt.Printf(<span class="string">&quot;b[:n] = %q\n&quot;</span>, b[:n])</span><br><span class="line"><span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p>图像：image 包定义了 Image 接口：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> image</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Image <span class="keyword">interface</span> &#123;</span><br><span class="line">    ColorModel() color.Model</span><br><span class="line">    Bounds() Rectangle</span><br><span class="line">    At(x, y <span class="type">int</span>) color.Color</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><h3 id="goroutine"><a href="#goroutine" class="headerlink" title="goroutine"></a>goroutine</h3><p>Go程（goroutine）：是由 Go 运行时管理的轻量级线程。<code>go f(x, y, z)</code>会启动一个新的 Go 程并执行。<code>f(x, y, z)f</code>, <code>x</code> , <code>y</code>和 <code>z</code>的求值发生在当前的 Go 程中，而 f 的执行发生在新的 Go 程中。</p><p>Go 程在相同的地址空间中运行，因此在访问共享的内存时必须进行同步,<code>sync</code>包提供了这种能力.</p><h3 id="信道"><a href="#信道" class="headerlink" title="信道"></a>信道</h3><p>信道：带有类型的管道，通过它用信道操作符<code>&lt;-</code> 来发送或者接收值。<br><code>ch &lt;- v    // 将 v 发送至信道 ch v := &lt;-ch  // 从 ch 接收值并赋予 v</code>(“箭头”就是数据流的方向)</p><p>信道在使用前必须创建：<code>ch := make(chan int)</code>默认情况下，发送和接收操作在另一端准备好之前都会阻塞。这使得 Go 程可以在没有<strong>显式的锁或竞态变量的情况下进行同步</strong>。没懂…..以下为<strong>gpt的形象解释</strong></p><blockquote><p>想象一下你正在组织一场接力赛。在这个接力赛中，每个参赛者（代表一个Goroutine）需要等待前一个队友完成他的部分并传递接力棒（代表信道中的数据）给他，然后他才能开始跑。如果前一个队友还没有跑到（即没有数据发送到信道），下一个队友（接收操作）就必须等待。反之，如果一个队友到达并准备传递接力棒，但下一个队友还没有准备好接手，他也需要等待。这个过程确保了所有的参赛者按照正确的顺序开始和完成他们的部分，没有人会跑得太早或太晚，从而无需额外的指示（即无需显式的锁）就自然而然地实现了同步。</p><p>通过使用信道的这种阻塞机制，Go能够在并发程序中简化数据的同步和通信，避免了直接使用锁或处理竞态变量的复杂性。这使得编写并发程序变得更加直观和安全。</p><p>具体例子：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(s []<span class="type">int</span>, c <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">sum := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">sum += v</span><br><span class="line">&#125;</span><br><span class="line">c &lt;- sum <span class="comment">// 将和送入 c</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := []<span class="type">int</span>&#123;<span class="number">7</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">-9</span>, <span class="number">4</span>, <span class="number">0</span>&#125;</span><br><span class="line"></span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"><span class="keyword">go</span> sum(s[:<span class="built_in">len</span>(s)/<span class="number">2</span>], c)</span><br><span class="line"><span class="keyword">go</span> sum(s[<span class="built_in">len</span>(s)/<span class="number">2</span>:], c)</span><br><span class="line">x, y := &lt;-c, &lt;-c <span class="comment">// 从 c 中接收</span></span><br><span class="line"></span><br><span class="line">fmt.Println(x, y, x+y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>带缓冲的信道：将缓冲长度作为第二个参数提供给 make 来初始化一个带缓冲的信道，<code>ch := make(chan int, 100)</code>;<strong>仅当信道的缓冲区填满后，向其发送数据时才会阻塞。当缓冲区为空时，接受方会阻塞</strong></p></blockquote><h3 id="range和close"><a href="#range和close" class="headerlink" title="range和close"></a>range和close</h3><p>发送者可通过<code>close</code>关闭一个信道来表示没有需要发送的值了。接收者可以通过为接收表达式分配第二个参数来测试信道是否被关闭：若没有值可以接收且信道已被关闭，那么在执行完<code>v, ok := &lt;-ch</code>之后<code>ok</code>会被设置为 false。</p><p>循环<code>for i := range c</code>会不断从信道接收值，直到它被关闭。</p><p><strong>WARNING:</strong> 只有发送者才能关闭信道，而接收者不能。向一个已经关闭的信道发送数据会引发程序恐慌（panic）。</p><p><strong>WARNING:</strong> 信道与文件不同，通常情况下无需关闭它们。只有在必须告诉接收者不再有需要发送的值时才有必要关闭，例如终止一个 range 循环。以下为示例：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibonacci</span><span class="params">(n <span class="type">int</span>, c <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">x, y := <span class="number">0</span>, <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">c &lt;- x</span><br><span class="line">x, y = y, x+y</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">close</span>(c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">10</span>)</span><br><span class="line"><span class="keyword">go</span> fibonacci(<span class="built_in">cap</span>(c), c)</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> c &#123;</span><br><span class="line">fmt.Println(i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h3 id="select语句"><a href="#select语句" class="headerlink" title="select语句"></a>select语句</h3><p><code>select</code>语句使一个 Go 程可以等待多个通信操作。</p><p><code>select</code>会阻塞到某个分支可以继续执行为止，这时就会执行该分支。当多个分支都准备好时会随机选择一个执行。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibonacci</span><span class="params">(c, quit <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">x, y := <span class="number">0</span>, <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> c &lt;- x:</span><br><span class="line">x, y = y, x+y</span><br><span class="line"><span class="keyword">case</span> &lt;-quit:</span><br><span class="line">fmt.Println(<span class="string">&quot;quit&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">quit := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">fmt.Println(&lt;-c)</span><br><span class="line">&#125;</span><br><span class="line">quit &lt;- <span class="number">0</span></span><br><span class="line">&#125;()</span><br><span class="line">fibonacci(c, quit)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>没懂…</p><p>默认选择：当 select 中的其它分支都没有准备好时，default 分支就会执行。为了在尝试发送或者接收时不发生阻塞，可使用 default 分支：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> i := &lt;-c:</span><br><span class="line">    <span class="comment">// 使用 i</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="comment">// 从 c 中接收会阻塞时执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="sync-Mutex"><a href="#sync-Mutex" class="headerlink" title="sync.Mutex"></a>sync.Mutex</h3><p>显而易见信道非常适合在各个 Go 程间进行通信。</p><p>但是如果我们并不需要通信呢？如果只是想保证每次只有一个 Go 程能够访问一个共享的变量，从而避免冲突？</p><p>这里涉及的概念叫做 <strong>互斥（mutual*exclusion）</strong> ，我们通常使用 <strong>互斥锁（Mutex）</strong> 这一数据结构来提供这种机制。</p><p>Go 标准库中提供了 <code>sync.Mutex</code>互斥锁类型及其两个方法：</p><ul><li><code>Lock</code></li><li><code>Unlock</code><br>我们可以通过在代码前调用<code>Lock</code>方法，在代码后调用<code>Unlock</code>方法来保证一段代码的互斥执行。参见 <code>Inc</code>方法。</li></ul><p>我们也可以用 defer 语句来保证互斥锁一定会被解锁。（参考<code>Value</code>方法）<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// SafeCounter 的并发使用是安全的。</span></span><br><span class="line"><span class="keyword">type</span> SafeCounter <span class="keyword">struct</span> &#123;</span><br><span class="line">v   <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span></span><br><span class="line">mux sync.Mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Inc 增加给定 key 的计数器的值。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *SafeCounter)</span></span> Inc(key <span class="type">string</span>) &#123;</span><br><span class="line">c.mux.Lock()</span><br><span class="line"><span class="comment">// Lock 之后同一时刻只有一个 goroutine 能访问 c.v</span></span><br><span class="line">c.v[key]++</span><br><span class="line">c.mux.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Value 返回给定 key 的计数器的当前值。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *SafeCounter)</span></span> Value(key <span class="type">string</span>) <span class="type">int</span> &#123;</span><br><span class="line">c.mux.Lock()</span><br><span class="line"><span class="comment">// Lock 之后同一时刻只有一个 goroutine 能访问 c.v</span></span><br><span class="line"><span class="keyword">defer</span> c.mux.Unlock()</span><br><span class="line"><span class="keyword">return</span> c.v[key]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">c := SafeCounter&#123;v: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> c.Inc(<span class="string">&quot;somekey&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">fmt.Println(c.Value(<span class="string">&quot;somekey&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><hr><p>芜湖…..整理完了，（应该是copy完了）；并发这块还不是很懂,其他还比较简单。<br>主要参考：<br>  <a href="https://tour.go-zh.org/">GO语言之旅</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;【Go学习记录】入门&quot;&gt;&lt;a href=&quot;#【Go学习记录】入门&quot; class=&quot;headerlink&quot; title=&quot;【Go学习记录】入门&quot;&gt;&lt;/a&gt;【Go学习记录】入门&lt;/h1&gt;&lt;p&gt;起步基础先跟着&lt;a href=&quot;https://tour.go-zh.org</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>TEST（博客又被我炸了，哈哈）</title>
    <link href="https://hongdouzza.github.io/posts/cd52ad99.html"/>
    <id>https://hongdouzza.github.io/posts/cd52ad99.html</id>
    <published>2024-03-26T21:39:25.000Z</published>
    <updated>2024-12-16T13:12:30.701Z</updated>
    
    <content type="html"><![CDATA[<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>POST的md文档，没有自动生成html文档？或者说html文档内容为空</p><h2 id="今天豆瓣把数据还没写完"><a href="#今天豆瓣把数据还没写完" class="headerlink" title="//今天豆瓣把数据还没写完"></a>//今天豆瓣把数据还没写完</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;测试&quot;&gt;&lt;a href=&quot;#测试&quot; class=&quot;headerlink&quot; title=&quot;测试&quot;&gt;&lt;/a&gt;测试&lt;/h2&gt;&lt;p&gt;POST的md文档，没有自动生成html文档？或者说html文档内容为空&lt;/p&gt;
&lt;h2 id=&quot;今天豆瓣把数据还没写完&quot;&gt;&lt;a href=</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>学生管理系统（C）</title>
    <link href="https://hongdouzza.github.io/posts/8810ab0d.html"/>
    <id>https://hongdouzza.github.io/posts/8810ab0d.html</id>
    <published>2024-03-26T11:52:28.000Z</published>
    <updated>2024-12-16T13:12:30.701Z</updated>
    
    <content type="html"><![CDATA[<h1 id="【C大作业】学生成绩管理系统（DDL：3-31）"><a href="#【C大作业】学生成绩管理系统（DDL：3-31）" class="headerlink" title="【C大作业】学生成绩管理系统（DDL：3.31）"></a>【C大作业】学生成绩管理系统（DDL：3.31）</h1><p> 背景：坏了，copy的代码还没读完，明天要交了（:cold_sweat:）</p><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>背景设置：</p><ul><li>教学班学生人数和课程门数受限制：<strong>学生人数&lt;=50</strong>，<strong>课程门数&lt;=10</strong></li><li>采用<strong>链表</strong>构成所有学生记录</li><li>使用结构体表示每个学生信息（学号、姓名、考试成绩）</li></ul><p>系统具备的功能：</p><ul><li>增：增加后的记录&lt;=50</li><li>删：删除多条记录</li><li>查：按<strong>学号和姓名</strong>查询</li><li>改</li><li>计算每位学生成绩总分和平均分</li><li>计算每门课总分和平均分</li><li>对学生记录排序：按学号升序、按姓名字典排序、按成绩总分/平均分排序</li><li>对学生记录统计：按成绩总分/平均分统计各个分数段的人数、占比，统计各个分数段人数、占比</li><li>数据存储：记录存盘操作，从磁盘读取已有学生记录</li></ul><h2 id="业务流程分析"><a href="#业务流程分析" class="headerlink" title="业务流程分析"></a>业务流程分析</h2><h2 id="文件结构："><a href="#文件结构：" class="headerlink" title="文件结构："></a>文件结构：</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;【C大作业】学生成绩管理系统（DDL：3-31）&quot;&gt;&lt;a href=&quot;#【C大作业】学生成绩管理系统（DDL：3-31）&quot; class=&quot;headerlink&quot; title=&quot;【C大作业】学生成绩管理系统（DDL：3.31）&quot;&gt;&lt;/a&gt;【C大作业】学生成绩管理系统</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>java_Learning1</title>
    <link href="https://hongdouzza.github.io/posts/dc874005.html"/>
    <id>https://hongdouzza.github.io/posts/dc874005.html</id>
    <published>2024-03-25T10:27:21.000Z</published>
    <updated>2024-12-16T13:12:30.701Z</updated>
    
    <content type="html"><![CDATA[<h1 id="【JAVA学习笔记1】-面向对象基础"><a href="#【JAVA学习笔记1】-面向对象基础" class="headerlink" title="【JAVA学习笔记1】 面向对象基础"></a>【JAVA学习笔记1】 面向对象基础</h1><p>JAVA知识点多，写点笔记，整理3.25 周一上午JAVA课内容，</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="private字段"><a href="#private字段" class="headerlink" title="private字段"></a>private字段</h3><p>当字段被修饰为<code>private</code>时，外部代码无法访问该字段。我们可以用调用类里的方法间接访问该字段，确保了封装性和安全性</p><h3 id="private方法"><a href="#private方法" class="headerlink" title="private方法"></a>private方法</h3><p>和<code>private</code>字段一样，<code>private</code>方法也不允许类外的代码调用。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">ming</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        ming.setBirth(<span class="number">2008</span>);</span><br><span class="line">        System.out.println(ming.getAge());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> birth;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBirth</span><span class="params">(<span class="type">int</span> birth)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.birth = birth;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> calcAge(<span class="number">2019</span>); <span class="comment">// 调用private方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// private方法:</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">calcAge</span><span class="params">(<span class="type">int</span> currentYear)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> currentYear - <span class="built_in">this</span>.birth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><blockquote><p>观察上述代码，<code>calcAge()</code>是一个<code>private</code>方法，外部代码无法调用，但是，内部方法<code>getAge()</code>可以调用它。此外，我们还注意到，这个<code>Person</code>类只定义了<code>birth</code>字段，没有定义<code>age</code>字段，获取<code>age</code>时，通过方法<code>getAge()</code>返回的是一个实时计算的值，并非存储在某个字段的值。这说明方法可以封装一个类的对外接口，调用方不需要知道也不关心<code>Person</code>实例在内部到底有没有<code>age</code>字段。</p></blockquote><h3 id="可变参数（E）"><a href="#可变参数（E）" class="headerlink" title="可变参数（E）"></a>可变参数（E）</h3><p>可变参数用类型…定义，可变参数相当于数组类型：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String[] names;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNames</span><span class="params">(String... names)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.names = names;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>上面的<code>setNames()</code>就定义了一个可变参数。调用时，可以这么写：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Animal</span> <span class="variable">g</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Animal</span>();</span><br><span class="line">g.setNames(<span class="string">&quot;cat&quot;</span>, <span class="string">&quot;dog&quot;</span>, <span class="string">&quot;cow&quot;</span>); <span class="comment">// 传入3个String</span></span><br><span class="line">g.setNames(<span class="string">&quot;cat&quot;</span>, <span class="string">&quot;dog&quot;</span>); <span class="comment">// 传入2个String</span></span><br><span class="line">g.setNames(<span class="string">&quot;cat&quot;</span>); <span class="comment">// 传入1个String</span></span><br><span class="line">g.setNames(); <span class="comment">// 传入0个String</span></span><br></pre></td></tr></table></figure><br>完全可以把可变参数改写为<code>String[]</code>类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String[] names;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNames</span><span class="params">(String[] names)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.names = names;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，调用方需要自己先构造<code>String[]</code>，比较麻烦。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Animal</span> <span class="variable">g</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Animal</span>();</span><br><span class="line">g.setNames(<span class="keyword">new</span> <span class="title class_">String</span>[] &#123;<span class="string">&quot;cat&quot;</span>, <span class="string">&quot;dog&quot;</span>, <span class="string">&quot;cow&quot;</span>&#125;); <span class="comment">// 传入1个String[]</span></span><br></pre></td></tr></table></figure><p>另一个问题是，调用方可以传入<code>null</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Animal</span> <span class="variable">g</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Animal</span>();</span><br><span class="line">g.setNames(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure><br>而可变参数可以保证无法传入null，因为传入0个参数时，接收到的实际值是一个空数组而不是null。</p><p>可变参数感觉跟重载异曲同工嘛，都由参数形式决定方法的结果。</p><h3 id="参数绑定（E）"><a href="#参数绑定（E）" class="headerlink" title="参数绑定（E）"></a>参数绑定（E）</h3><blockquote><p>调用方把参数传递给实例方法时，调用时传递的值会按参数位置一一绑定。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基本类型参数绑定</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">15</span>; <span class="comment">// n的值为15</span></span><br><span class="line">        p.setAge(n); <span class="comment">// 传入n的值</span></span><br><span class="line">        System.out.println(p.getAge()); <span class="comment">// 15</span></span><br><span class="line">        n = <span class="number">20</span>; <span class="comment">// n的值改为20</span></span><br><span class="line">        System.out.println(p.getAge()); <span class="comment">// 15还是20?</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>此时<code>n</code>和<code>p.age</code>两者互不影响，<code>setAge()</code>方法复制了<code>n</code>的值</p></blockquote><p>重点：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//引用类型参数绑定</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        String[] fullname = <span class="keyword">new</span> <span class="title class_">String</span>[] &#123; <span class="string">&quot;Homer&quot;</span>, <span class="string">&quot;Simpson&quot;</span> &#125;;</span><br><span class="line">        p.setName(fullname); <span class="comment">// 传入fullname数组</span></span><br><span class="line">        System.out.println(p.getName()); <span class="comment">// &quot;Homer Simpson&quot;</span></span><br><span class="line">        fullname[<span class="number">0</span>] = <span class="string">&quot;Bart&quot;</span>; <span class="comment">// fullname数组的第一个元素修改为&quot;Bart&quot;</span></span><br><span class="line">        System.out.println(p.getName()); <span class="comment">// &quot;Homer Simpson&quot;还是&quot;Bart Simpson&quot;?</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String[] name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name[<span class="number">0</span>] + <span class="string">&quot; &quot;</span> + <span class="built_in">this</span>.name[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String[] name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><code>fullname</code>和<code>name</code>同步更改，原因是<code>new String[]&#123;&#125;</code><strong>创建了一个对象</strong>，而<code>fullname</code>和<code>p.name</code><strong>指向了同一个对象</strong>。关键是创建了一个对象</p><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p> 构造方法初始化实例，<strong>构造方法名就是类名</strong>，<strong>无返回值</strong>。<br> 调用该方法，必须用<code>new</code>操作符</p><p> 如果既对字段进行初始化，又在构造方法中对字段进行初始化,会发生什么？</p><p> 在Java中，创建对象实例的时候，按照如下顺序进行初始化：</p><ul><li><p>先初始化字段：int age = 10;表示字段初始化为10，double salary;表示字段默认初始化为0，String name;表示引用类型字段默认初始化为null；</p></li><li><p>执行构造方法的代码进行初始化。</p></li></ul><p>因此，构造方法的代码是后运行，将覆盖一开始字段初始化。</p><p>多构造方法，用法类似方法重载。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = <span class="number">12</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h2 id="方法重载-OverLoad-："><a href="#方法重载-OverLoad-：" class="headerlink" title="方法重载(OverLoad)："></a>方法重载(<code>OverLoad</code>)：</h2><p><strong>同一个类</strong>里定义几个<strong>方法名相同</strong>，功能相似但<strong>参数不同</strong>（参数个数、参数类型不同）的<strong>方法</strong></p><p>换而言之，以参数内容决定方法内容，省去多个函数名</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, &quot;</span> + name + <span class="string">&quot;!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (age &lt; <span class="number">18</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Hi, &quot;</span> + name + <span class="string">&quot;!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Hello, &quot;</span> + name + <span class="string">&quot;!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//当前对象是p1；</span></span><br><span class="line">p1.distance(p2);</span><br><span class="line"><span class="comment">//static?</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">double</span> <span class="title function_">distance</span><span class="params">(Point c,Point d)</span>&#123;&#125;<span class="comment">//类是一种数据类型，static静态函数可省略调用对象</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h2 id="其他知识点"><a href="#其他知识点" class="headerlink" title="其他知识点"></a>其他知识点</h2><p><code>this</code>的用法、对象运算符、匿名对象（类）、包和修饰符</p><h3 id="this-用法"><a href="#this-用法" class="headerlink" title="this 用法"></a>this 用法</h3><ul><li>调用类内的成员变量<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> num;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNum</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.num = num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>调用本类中的其他方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> num;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(MyClass mc)</span> &#123;</span><br><span class="line">        System.out.println(mc.num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>调用本类中的其他构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> num;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyClass</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyClass</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.num = num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="对象运算符-instanceof"><a href="#对象运算符-instanceof" class="headerlink" title="对象运算符(instanceof)"></a>对象运算符(instanceof)</h3><p>该运算符用于操作对象实例，检查该对象是否是一个特定类型（类类型或接口类型）。</p><p><code>instanceof</code>运算符使用格式如下：</p><p>( Object reference variable ) instanceof  (class/interface type)<br>如果运算符左侧变量所指的对象，是操作符右侧类或接口(class/interface)的一个对象，那么结果为真。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;James&quot;</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> name <span class="keyword">instanceof</span> String; <span class="comment">// 由于 name 是 String 类型，所以返回真</span></span><br></pre></td></tr></table></figure><p>如果被比较的对象兼容于右侧类型，该运算符仍然返回 true。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vehicle</span> &#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Car</span> <span class="keyword">extends</span> <span class="title class_">Vehicle</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">      <span class="type">Vehicle</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Car</span>();</span><br><span class="line">      <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span>  a <span class="keyword">instanceof</span> Car;</span><br><span class="line">      System.out.println( result);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上实例编译运行结果为：<code>true</code></p><h3 id="匿名对象"><a href="#匿名对象" class="headerlink" title="匿名对象"></a>匿名对象</h3><p>普通的类对象在使用时会<strong>定义一个类类型的变量</strong>，用来保存new出来的类所在的地址。而匿名类取<strong>消掉了这个变量</strong>，这个地址由编译器来处理，并且在new出来之后，它占用的内存会有<strong>JVM自动回收掉</strong>。后续无法再使用了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">classBegin</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;豆zza来喽ヘ(~ω~ヘ)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Student</span>().classBegin();</span><br></pre></td></tr></table></figure><p>匿名对象最常用的方式是<strong>作为函数的参数</strong>，上述的打印语句 “豆zza来喽ヘ(~ω~ヘ)” 是一个匿名对象，由于字符串是以对象的形式存储的，所以这里实际上就是一个<strong>没有使用对象引用的匿名对象</strong>。</p><h3 id="匿名类"><a href="#匿名类" class="headerlink" title="匿名类"></a>匿名类</h3><p>如果一个内部类在整个操作中<strong>只使用一次</strong>，就可以定义为匿名内部类。匿名内部类也就是没有名字的内部类，这是java为了方便我们编写程序而设计的一个机制.<strong>只创建一个它的对象</strong>，以后再不会用到这个类，使用匿名内部类就比较合适。</p><p>匿名内部类伴随着接口一起使用:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">USB</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">USB</span> <span class="variable">usb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">USB</span>()&#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        usb.open();</span><br><span class="line">        usb.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用匿名内部类的匿名对象的方式</span></span><br><span class="line">        <span class="type">USB</span> <span class="variable">usb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">USB</span>()&#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">        &#125;.open();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在Demo这个类的main方法中创建了一个局部的内部类，这个内部类没有名字，也就是创建了一个匿名内部类。</p><p>匿名对象（类）中文本均来自 *<a href="https://cloud.tencent.com/developer/article/1444362">Java 学习笔记(8)——匿名对象与内部类</a></p><h3 id="包-package"><a href="#包-package" class="headerlink" title="包(package)"></a>包(package)</h3><ul><li>将功能相近的类放在同一个包里</li><li>某些访问是以包为单位</li><li>由于不同包里可能有相同的类名，一定程度上可以避免命名冲突</li><li>package语句必须是文件中第一条语句</li><li><strong>WARNING</strong> :包没有父子关系。java.util和java.util.zip是不同的包，两者没有任何继承关系。</li></ul><h3 id="private、public、protected、无修饰"><a href="#private、public、protected、无修饰" class="headerlink" title="private、public、protected、无修饰"></a>private、public、protected、无修饰</h3><div class="table-container"><table><thead><tr><th style="text-align:left">访问级别</th><th style="text-align:left">访问控制修饰符</th><th style="text-align:left">同类</th><th style="text-align:left">同包</th><th style="text-align:left">子类</th><th style="text-align:left">不同包</th></tr></thead><tbody><tr><td style="text-align:left">公开</td><td style="text-align:left">public</td><td style="text-align:left">✔</td><td style="text-align:left">✔</td><td style="text-align:left">✔</td><td style="text-align:left">✔</td></tr><tr><td style="text-align:left">受保护</td><td style="text-align:left">protected</td><td style="text-align:left">✔</td><td style="text-align:left">✔</td><td style="text-align:left">✔</td><td style="text-align:left">×</td></tr><tr><td style="text-align:left">默认</td><td style="text-align:left">无修饰符</td><td style="text-align:left">✔</td><td style="text-align:left">✔</td><td style="text-align:left">×</td><td style="text-align:left">×</td></tr><tr><td style="text-align:left">私有</td><td style="text-align:left">private</td><td style="text-align:left">✔</td><td style="text-align:left">×</td><td style="text-align:left">×</td><td style="text-align:left">×</td></tr></tbody></table></div><hr><p>主要参考：</p><ul><li>java上课内容</li><li><a href="https://www.liaoxuefeng.com/wiki/1252599548343744">廖雪峰java课堂</a></li><li><a href="https://cloud.tencent.com/developer/article/1444362">Java 学习笔记(8)——匿名对象与内部类</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;【JAVA学习笔记1】-面向对象基础&quot;&gt;&lt;a href=&quot;#【JAVA学习笔记1】-面向对象基础&quot; class=&quot;headerlink&quot; title=&quot;【JAVA学习笔记1】 面向对象基础&quot;&gt;&lt;/a&gt;【JAVA学习笔记1】 面向对象基础&lt;/h1&gt;&lt;p&gt;JAVA知识</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>下学期任务清单</title>
    <link href="https://hongdouzza.github.io/posts/2cb79163.html"/>
    <id>https://hongdouzza.github.io/posts/2cb79163.html</id>
    <published>2024-03-21T23:30:46.000Z</published>
    <updated>2024-12-16T13:12:30.701Z</updated>
    
    <content type="html"><![CDATA[<h1 id="【随笔】大一下的开学"><a href="#【随笔】大一下的开学" class="headerlink" title="【随笔】大一下的开学"></a>【随笔】大一下的开学</h1><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>3月2号开学，嗯，现在大概三个星期过去了。除了离散、大物、近代史，其他课一概是能翘就翘，不能翘就写作业，属实无聊。无聊嘛，就水水杭助群，翻翻大佬们的博客(<del>虽然越刷越焦虑</del>:joy:)。但刷着刷着，想起这样一句话</p><blockquote><p>人无癖，不可交   ——《幽梦影》  </p><p>人无癖，不可交。所谓“癖”，是内心充满热情的源头。而我身上热情和勇气几乎已经被迷茫和焦虑压垮了。</p></blockquote><h3 id="迷茫与焦虑"><a href="#迷茫与焦虑" class="headerlink" title="迷茫与焦虑"></a>迷茫与焦虑</h3><p>   说实话，java课硬生生上成了语法课，三节课昏昏沉沉过去，结果对自己“要学”的一无所知。高数课也是如此，真不如我自学，半个小时能抵得上她讲三节课。  </p><p>   必修课是这个状态，那么想着给自己补点人文素养，选了几门人文公选课。一个是讲道德经的，打着当代价值的旗号，<strong>实质除了给现有世界政治经济模式背书，就空空如也</strong>，讲课没有批判力，更没有辩证法，漫画化、正面化的成功人士充斥课堂。WTO嘛，蜻蜓点水，简单性介绍知识，没意思。  </p><p>   这些都是热门课，公评所谓“有真才”“给分高”，去年抢到手可是兴奋了好一阵子，可事实证明</p><blockquote><p>人不能总抱有过高的期待</p></blockquote><p>   最近寝室也出现些矛盾，开麦游戏太吵的，说我弹琴太吵，拌了口角，也没有下文；洗衣机也总是洗出纸屑，很烦，结果也没人主动处理干净；今天下文花了半个小时“起草”寝室规定，也不知道能不能开个小会通过规定。<strong>本以为只有五个人的世界是不需要成文规定的</strong></p><p>  最近还有好多事情要做。互联网+的项目感觉<strong>没戏</strong>。看着商业计划书，有虚玄的感觉。我接口一个都没做。(寄:cold_sweat:)下周五，还有个藤廊音乐节，准备带两首ballad过去，合奏还没练好。</p><p>  说起指弹，我的音乐之路。上个月投的<strong>natasha初赛</strong>石沉大海,结果排了一百多名，没进复赛。不过确实，收音没整好，机位又摆的一坨:hankey:，是我的问题，是我的问题…….</p><p>  现在寝室里人越来越少，恋爱的、团建的、开会的，嗯….</p><p><strong>我该何去何从</strong></p><h3 id="何去何从"><a href="#何去何从" class="headerlink" title="何去何从"></a>何去何从</h3><p>我高中时想当物理学家，努力过，算的上中上水平，但属实没有天赋，加上高考失利，读了计算机。身边佬都是打过noip的，上个学期想了一个月的acm，后来还是放弃，恐怕入了队，最后也会被末尾淘汰，实在没有勇气（<del>陪了夫人又折兵</del>）</p><p>读CS，也学大物，没了当初的热情，现在才发觉</p><blockquote><p>物理学不是我的热爱所在</p></blockquote><p>不打acm，不想去学生组织，想着总要有个技术团体吧，在计科协的介绍下认识了杭助。作为小白，啥都不懂，国庆花了一个星期做面试题，最后很幸运过了。现在想想，真的很幸运。在这里，你遇到到一群真心热爱技术的伙伴（<del>尽管我只会复读，插不上话</del>）。</p><p>所以将来，我是找工作呢，还是读研，还是卷GPA保研呢？</p><p>不管那么多，先提升自己再说。</p><h3 id="提升自己"><a href="#提升自己" class="headerlink" title="提升自己"></a>提升自己</h3><p>我大概两条路线：做音乐、做IT技术。列个这学期的清单</p><p> 后端学习清单：</p><ul><li>学完GO</li><li>学习<code>mysql</code>数据库基础</li><li>学<code>Linux</code></li><li>算法学一下（算法竞赛）</li><li><strong>日更博客</strong>（<del>一般是技术博客</del>）</li><li><a href="https://itwanger.gitee.io/tobebetterjavaer/#/docs/xuexiluxian/go">GO进阶之路</a><br><img src="http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/xuexiluxian/go-7.jpg" alt="附上GO学习路线"></li></ul><p>音乐路线任务清单：</p><ul><li>[ ] 学完爵士和声所有内容</li><li>[ ] 在指板上展现理论内容</li><li>[ ] 每周扒带一首</li><li>[ ] 写点曲子</li><li>[ ] 参加WAGF、吉他中国举办的比赛.(今年翻弹组，明年在走原创)</li><li>[ ] 学混音（EQ、压缩、混响、母带）</li></ul><p>就这样吧，现在刚好是22号零点。<strong>搁笔睡觉！</strong></p><span id="more"></span>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;【随笔】大一下的开学&quot;&gt;&lt;a href=&quot;#【随笔】大一下的开学&quot; class=&quot;headerlink&quot; title=&quot;【随笔】大一下的开学&quot;&gt;&lt;/a&gt;【随笔】大一下的开学&lt;/h1&gt;&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;3月2号开学，嗯，现在大概三个星期过去了。除了离散、大物、近代史，其他课一概是能翘就翘，不能翘就写作业，属实无聊。无聊嘛，就水水杭助群，翻翻大佬们的博客(&lt;del&gt;虽然越刷越焦虑&lt;/del&gt;:joy:)。但刷着刷着，想起这样一句话&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;人无癖，不可交   ——《幽梦影》  &lt;/p&gt;
&lt;p&gt;人无癖，不可交。所谓“癖”，是内心充满热情的源头。而我身上热情和勇气几乎已经被迷茫和焦虑压垮了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;迷茫与焦虑&quot;&gt;&lt;a href=&quot;#迷茫与焦虑&quot; class=&quot;headerlink&quot; title=&quot;迷茫与焦虑&quot;&gt;&lt;/a&gt;迷茫与焦虑&lt;/h3&gt;&lt;p&gt;   说实话，java课硬生生上成了语法课，三节课昏昏沉沉过去，结果对自己“要学”的一无所知。高数课也是如此，真不如我自学，半个小时能抵得上她讲三节课。  &lt;/p&gt;
&lt;p&gt;   必修课是这个状态，那么想着给自己补点人文素养，选了几门人文公选课。一个是讲道德经的，打着当代价值的旗号，&lt;strong&gt;实质除了给现有世界政治经济模式背书，就空空如也&lt;/strong&gt;，讲课没有批判力，更没有辩证法，漫画化、正面化的成功人士充斥课堂。WTO嘛，蜻蜓点水，简单性介绍知识，没意思。  &lt;/p&gt;
&lt;p&gt;   这些都是热门课，公评所谓“有真才”“给分高”，去年抢到手可是兴奋了好一阵子，可事实证明&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;人不能总抱有过高的期待&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;   最近寝室也出现些矛盾，开麦游戏太吵的，说我弹琴太吵，拌了口角，也没有下文；洗衣机也总是洗出纸屑，很烦，结果也没人主动处理干净；今天下文花了半个小时“起草”寝室规定，也不知道能不能开个小会通过规定。&lt;strong&gt;本以为只有五个人的世界是不需要成文规定的&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;  最近还有好多事情要做。互联网+的项目感觉&lt;strong&gt;没戏&lt;/strong&gt;。看着商业计划书，有虚玄的感觉。我接口一个都没做。(寄:cold_sweat:)下周五，还有个藤廊音乐节，准备带两首ballad过去，合奏还没练好。&lt;/p&gt;
&lt;p&gt;  说起指弹，我的音乐之路。上个月投的&lt;strong&gt;natasha初赛&lt;/strong&gt;石沉大海,结果排了一百多名，没进复赛。不过确实，收音没整好，机位又摆的一坨:hankey:，是我的问题，是我的问题…….&lt;/p&gt;
&lt;p&gt;  现在寝室里人越来越少，恋爱的、团建的、开会的，嗯….&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我该何去何从&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;何去何从&quot;&gt;&lt;a href=&quot;#何去何从&quot; class=&quot;headerlink&quot; title=&quot;何去何从&quot;&gt;&lt;/a&gt;何去何从&lt;/h3&gt;&lt;p&gt;我高中时想当物理学家，努力过，算的上中上水平，但属实没有天赋，加上高考失利，读了计算机。身边佬都是打过noip的，上个学期想了一个月的acm，后来还是放弃，恐怕入了队，最后也会被末尾淘汰，实在没有勇气（&lt;del&gt;陪了夫人又折兵&lt;/del&gt;）&lt;/p&gt;
&lt;p&gt;读CS，也学大物，没了当初的热情，现在才发觉&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;物理学不是我的热爱所在&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;不打acm，不想去学生组织，想着总要有个技术团体吧，在计科协的介绍下认识了杭助。作为小白，啥都不懂，国庆花了一个星期做面试题，最后很幸运过了。现在想想，真的很幸运。在这里，你遇到到一群真心热爱技术的伙伴（&lt;del&gt;尽管我只会复读，插不上话&lt;/del&gt;）。&lt;/p&gt;
&lt;p&gt;所以将来，我是找工作呢，还是读研，还是卷GPA保研呢？&lt;/p&gt;
&lt;p&gt;不管那么多，先提升自己再说。&lt;/p&gt;
&lt;h3 id=&quot;提升自己&quot;&gt;&lt;a href=&quot;#提升自己&quot; class=&quot;headerlink&quot; title=&quot;提升自己&quot;&gt;&lt;/a&gt;提升自己&lt;/h3&gt;&lt;p&gt;我大概两条路线：做音乐、做IT技术。列个这学期的清单&lt;/p&gt;
&lt;p&gt; 后端学习清单：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;学完GO&lt;/li&gt;
&lt;li&gt;学习&lt;code&gt;mysql&lt;/code&gt;数据库基础&lt;/li&gt;
&lt;li&gt;学&lt;code&gt;Linux&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;算法学一下（算法竞赛）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;日更博客&lt;/strong&gt;（&lt;del&gt;一般是技术博客&lt;/del&gt;）&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://itwanger.gitee.io/tobebetterjavaer/#/docs/xuexiluxian/go&quot;&gt;GO进阶之路&lt;/a&gt;&lt;br&gt;&lt;img src=&quot;http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/xuexiluxian/go-7.jpg&quot; alt=&quot;附上GO学习路线&quot;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;音乐路线任务清单：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;[ ] 学完爵士和声所有内容&lt;/li&gt;
&lt;li&gt;[ ] 在指板上展现理论内容&lt;/li&gt;
&lt;li&gt;[ ] 每周扒带一首&lt;/li&gt;
&lt;li&gt;[ ] 写点曲子&lt;/li&gt;
&lt;li&gt;[ ] 参加WAGF、吉他中国举办的比赛.(今年翻弹组，明年在走原创)&lt;/li&gt;
&lt;li&gt;[ ] 学混音（EQ、压缩、混响、母带）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;就这样吧，现在刚好是22号零点。&lt;strong&gt;搁笔睡觉！&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
</feed>
